<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>100 Exercises To Learn Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro/00_welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_intro/01_syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="02_basic_calculator/00_intro.html"><strong aria-hidden="true">2.</strong> A Basic Calculator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_basic_calculator/01_integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/02_variables.html"><strong aria-hidden="true">2.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/03_if_else.html"><strong aria-hidden="true">2.3.</strong> Branching: if/else</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/04_panics.html"><strong aria-hidden="true">2.4.</strong> Panics</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/05_factorial.html"><strong aria-hidden="true">2.5.</strong> Factorial</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/06_while.html"><strong aria-hidden="true">2.6.</strong> Loops: while</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/07_for.html"><strong aria-hidden="true">2.7.</strong> Loops: for</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/08_overflow.html"><strong aria-hidden="true">2.8.</strong> Overflow and underflow</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/09_saturating.html"><strong aria-hidden="true">2.9.</strong> Saturating arithmetic</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/10_as_casting.html"><strong aria-hidden="true">2.10.</strong> Conversions: as casting</a></li></ol></li><li class="chapter-item expanded "><a href="03_ticket_v1/00_intro.html"><strong aria-hidden="true">3.</strong> Ticket v1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_ticket_v1/01_struct.html"><strong aria-hidden="true">3.1.</strong> Structs</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/02_validation.html"><strong aria-hidden="true">3.2.</strong> Validation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/03_modules.html"><strong aria-hidden="true">3.3.</strong> Modules</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/04_visibility.html"><strong aria-hidden="true">3.4.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/05_encapsulation.html"><strong aria-hidden="true">3.5.</strong> Encapsulation</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/06_ownership.html"><strong aria-hidden="true">3.6.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/07_setters.html"><strong aria-hidden="true">3.7.</strong> Setters</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/08_stack.html"><strong aria-hidden="true">3.8.</strong> Stack</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/09_heap.html"><strong aria-hidden="true">3.9.</strong> Heap</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/10_references_in_memory.html"><strong aria-hidden="true">3.10.</strong> References in memory</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/11_destructor.html"><strong aria-hidden="true">3.11.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/12_outro.html"><strong aria-hidden="true">3.12.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="04_traits/00_intro.html"><strong aria-hidden="true">4.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_traits/01_trait.html"><strong aria-hidden="true">4.1.</strong> Trait</a></li><li class="chapter-item expanded "><a href="04_traits/02_orphan_rule.html"><strong aria-hidden="true">4.2.</strong> Orphan rule</a></li><li class="chapter-item expanded "><a href="04_traits/03_operator_overloading.html"><strong aria-hidden="true">4.3.</strong> Operator overloading</a></li><li class="chapter-item expanded "><a href="04_traits/04_derive.html"><strong aria-hidden="true">4.4.</strong> Derive macros</a></li><li class="chapter-item expanded "><a href="04_traits/05_trait_bounds.html"><strong aria-hidden="true">4.5.</strong> Trait bounds</a></li><li class="chapter-item expanded "><a href="04_traits/06_str_slice.html"><strong aria-hidden="true">4.6.</strong> String slices</a></li><li class="chapter-item expanded "><a href="04_traits/07_deref.html"><strong aria-hidden="true">4.7.</strong> Deref trait</a></li><li class="chapter-item expanded "><a href="04_traits/08_sized.html"><strong aria-hidden="true">4.8.</strong> Sized trait</a></li><li class="chapter-item expanded "><a href="04_traits/09_from.html"><strong aria-hidden="true">4.9.</strong> From trait</a></li><li class="chapter-item expanded "><a href="04_traits/10_assoc_vs_generic.html"><strong aria-hidden="true">4.10.</strong> Associated vs generic types</a></li><li class="chapter-item expanded "><a href="04_traits/11_clone.html"><strong aria-hidden="true">4.11.</strong> Clone trait</a></li><li class="chapter-item expanded "><a href="04_traits/12_copy.html"><strong aria-hidden="true">4.12.</strong> Copy trait</a></li><li class="chapter-item expanded "><a href="04_traits/13_drop.html"><strong aria-hidden="true">4.13.</strong> Drop trait</a></li><li class="chapter-item expanded "><a href="04_traits/14_outro.html"><strong aria-hidden="true">4.14.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="05_ticket_v2/00_intro.html"><strong aria-hidden="true">5.</strong> Ticket v2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_ticket_v2/01_enum.html"><strong aria-hidden="true">5.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/02_match.html"><strong aria-hidden="true">5.2.</strong> Branching: match</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/03_variants_with_data.html"><strong aria-hidden="true">5.3.</strong> Variants with data</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/04_if_let.html"><strong aria-hidden="true">5.4.</strong> Branching: if let and let/else</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/05_nullability.html"><strong aria-hidden="true">5.5.</strong> Nullability</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/06_fallibility.html"><strong aria-hidden="true">5.6.</strong> Fallibility</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/07_unwrap.html"><strong aria-hidden="true">5.7.</strong> Unwrap</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/08_error_enums.html"><strong aria-hidden="true">5.8.</strong> Error enums</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/09_error_trait.html"><strong aria-hidden="true">5.9.</strong> Error trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/10_packages.html"><strong aria-hidden="true">5.10.</strong> Packages</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/11_dependencies.html"><strong aria-hidden="true">5.11.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/12_thiserror.html"><strong aria-hidden="true">5.12.</strong> thiserror</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/13_try_from.html"><strong aria-hidden="true">5.13.</strong> TryFrom trait</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/14_source.html"><strong aria-hidden="true">5.14.</strong> Error::source</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/15_outro.html"><strong aria-hidden="true">5.15.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="06_ticket_management/00_intro.html"><strong aria-hidden="true">6.</strong> Ticket Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_ticket_management/01_arrays.html"><strong aria-hidden="true">6.1.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="06_ticket_management/02_vec.html"><strong aria-hidden="true">6.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="06_ticket_management/03_resizing.html"><strong aria-hidden="true">6.3.</strong> Resizing</a></li><li class="chapter-item expanded "><a href="06_ticket_management/04_iterators.html"><strong aria-hidden="true">6.4.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/05_iter.html"><strong aria-hidden="true">6.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="06_ticket_management/06_lifetimes.html"><strong aria-hidden="true">6.6.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="06_ticket_management/07_combinators.html"><strong aria-hidden="true">6.7.</strong> Combinators</a></li><li class="chapter-item expanded "><a href="06_ticket_management/08_impl_trait.html"><strong aria-hidden="true">6.8.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/09_impl_trait_2.html"><strong aria-hidden="true">6.9.</strong> impl Trait, pt.2</a></li><li class="chapter-item expanded "><a href="06_ticket_management/10_slices.html"><strong aria-hidden="true">6.10.</strong> Slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/11_mutable_slices.html"><strong aria-hidden="true">6.11.</strong> Mutable slices</a></li><li class="chapter-item expanded "><a href="06_ticket_management/12_two_states.html"><strong aria-hidden="true">6.12.</strong> Two states</a></li><li class="chapter-item expanded "><a href="06_ticket_management/13_index.html"><strong aria-hidden="true">6.13.</strong> Index trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/14_index_mut.html"><strong aria-hidden="true">6.14.</strong> IndexMut trait</a></li><li class="chapter-item expanded "><a href="06_ticket_management/15_hashmap.html"><strong aria-hidden="true">6.15.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="06_ticket_management/16_btreemap.html"><strong aria-hidden="true">6.16.</strong> BTreeMap</a></li></ol></li><li class="chapter-item expanded "><a href="07_threads/00_intro.html"><strong aria-hidden="true">7.</strong> Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_threads/01_threads.html"><strong aria-hidden="true">7.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="07_threads/02_static.html"><strong aria-hidden="true">7.2.</strong> 'static lifetime</a></li><li class="chapter-item expanded "><a href="07_threads/03_leak.html"><strong aria-hidden="true">7.3.</strong> Leaking memory</a></li><li class="chapter-item expanded "><a href="07_threads/04_scoped_threads.html"><strong aria-hidden="true">7.4.</strong> Scoped threads</a></li><li class="chapter-item expanded "><a href="07_threads/05_channels.html"><strong aria-hidden="true">7.5.</strong> Channels</a></li><li class="chapter-item expanded "><a href="07_threads/06_interior_mutability.html"><strong aria-hidden="true">7.6.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="07_threads/07_ack.html"><strong aria-hidden="true">7.7.</strong> Ack pattern</a></li><li class="chapter-item expanded "><a href="07_threads/08_client.html"><strong aria-hidden="true">7.8.</strong> Client</a></li><li class="chapter-item expanded "><a href="07_threads/09_bounded.html"><strong aria-hidden="true">7.9.</strong> Bounded channels</a></li><li class="chapter-item expanded "><a href="07_threads/10_patch.html"><strong aria-hidden="true">7.10.</strong> Patching</a></li><li class="chapter-item expanded "><a href="07_threads/11_locks.html"><strong aria-hidden="true">7.11.</strong> Mutex, Send and Arc</a></li><li class="chapter-item expanded "><a href="07_threads/12_rw_lock.html"><strong aria-hidden="true">7.12.</strong> RwLock</a></li><li class="chapter-item expanded "><a href="07_threads/13_without_channels.html"><strong aria-hidden="true">7.13.</strong> Without channels</a></li><li class="chapter-item expanded "><a href="07_threads/14_sync.html"><strong aria-hidden="true">7.14.</strong> Sync trait</a></li></ol></li><li class="chapter-item expanded "><a href="08_futures/00_intro.html"><strong aria-hidden="true">8.</strong> Futures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_futures/01_async_fn.html"><strong aria-hidden="true">8.1.</strong> Asynchronous functions</a></li><li class="chapter-item expanded "><a href="08_futures/02_spawn.html"><strong aria-hidden="true">8.2.</strong> Spawning tasks</a></li><li class="chapter-item expanded "><a href="08_futures/03_runtime.html"><strong aria-hidden="true">8.3.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="08_futures/04_future.html"><strong aria-hidden="true">8.4.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="08_futures/05_blocking.html"><strong aria-hidden="true">8.5.</strong> Blocking the runtime</a></li><li class="chapter-item expanded "><a href="08_futures/06_async_aware_primitives.html"><strong aria-hidden="true">8.6.</strong> Async-aware primitives</a></li><li class="chapter-item expanded "><a href="08_futures/07_cancellation.html"><strong aria-hidden="true">8.7.</strong> Cancellation</a></li><li class="chapter-item expanded "><a href="08_futures/08_outro.html"><strong aria-hidden="true">8.8.</strong> Outro</a></li></ol></li><li class="chapter-item expanded "><a href="going_further.html"><strong aria-hidden="true">9.</strong> Going further</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">100 Exercises To Learn Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mainmatter/100-exercises-to-learn-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to <strong>"100 Exercises To Learn Rust"</strong>!</p>
<p>This course will teach you Rust's core concepts, one exercise at a time.<br />
You'll learn about Rust's syntax, its type system, its standard library, and its ecosystem.</p>
<p>We don't assume any prior knowledge of Rust, but we assume you know at least
another programming language.
We also don't assume any prior knowledge of systems programming or memory management. Those
topics will be covered in the course.</p>
<p>In other words, we'll be starting from scratch!<br />
You'll build up your Rust knowledge in small, manageable steps.
By the end of the course, you will have solved ~100 exercises, enough to
feel comfortable working on small to medium-sized Rust projects.</p>
<h2 id="methodology"><a class="header" href="#methodology">Methodology</a></h2>
<p>This course is based on the "learn by doing" principle.<br />
It has been designed to be interactive and hands-on.</p>
<p><a href="https://mainmatter.com/rust-consulting/">Mainmatter</a> developed this course
to be delivered in a classroom setting, over 4 days: each attendee advances
through the lessons at their own pace, with an experienced instructor providing
guidance, answering questions and diving deeper into the topics as needed.<br />
If you're interested in attending one of our training sessions, or if you'd like to
bring this course to your company, please <a href="https://mainmatter.com/contact/">get in touch</a>.</p>
<p>You can also follow the course on your own, but we recommend you find a friend or
a mentor to help you along the way should you get stuck. You can
also find solutions to all exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions"><code>solutions</code> branch of the GitHub repository</a>.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>On the left side of the screen, you can see that the course is divided into sections.
Each section introduces a new concept or feature of the Rust language.<br />
To verify your understanding, each section is paired with an exercise that you need to solve.</p>
<p>You can find the exercises in the
<a href="https://github.com/mainmatter/100-exercises-to-learn-rust">companion GitHub repository</a>.<br />
Before starting the course, make sure to clone the repository to your local machine:</p>
<pre><code class="language-bash"># If you have an SSH key set up with GitHub
git clone git@github.com:mainmatter/100-exercises-to-learn-rust.git
# Otherwise, use the HTTPS URL:
#
#   git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git
</code></pre>
<p>We also recommend you work on a branch, so you can easily track your progress and pull
in updates from the main repository, if needed:</p>
<pre><code class="language-bash">cd 100-exercises-to-learn-rust
git checkout -b my-solutions
</code></pre>
<p>All exercises are located in the <code>exercises</code> folder.
Each exercise is structured as a Rust package.
The package contains the exercise itself, instructions on what to do (in <code>src/lib.rs</code>), and a test suite to
automatically verify your solution.</p>
<h3 id="wr-the-workshop-runner"><a class="header" href="#wr-the-workshop-runner"><code>wr</code>, the workshop runner</a></h3>
<p>To verify your solutions, we've provided a tool that will guide you through the course.
It is the <code>wr</code> CLI (short for "workshop runner").
Install it with:</p>
<pre><code class="language-bash">cargo install --locked workshop-runner
</code></pre>
<p>In a new terminal, navigate back to the top-level folder of the repository.
Run the <code>wr</code> command to start the course:</p>
<pre><code class="language-bash">wr
</code></pre>
<p><code>wr</code> will verify the solution to the current exercise.<br />
Don't move on to the next section until you've solved the exercise for the current one.</p>
<blockquote>
<p>We recommend committing your solutions to Git as you progress through the course,
so you can easily track your progress and "restart" from a known point if needed.</p>
</blockquote>
<p>Enjoy the course!</p>
<h2 id="author"><a class="header" href="#author">Author</a></h2>
<p>This course was written by <a href="https://www.lpalmieri.com/">Luca Palmieri</a>, Principal Engineering
Consultant at <a href="https://mainmatter.com/rust-consulting/">Mainmatter</a>.<br />
Luca has been working with Rust since 2018, initially at TrueLayer and then at AWS.<br />
Luca is the author of <a href="https://zero2prod.com">"Zero to Production in Rust"</a>,
the go-to resource for learning how to build backend applications in Rust.<br />
He is also the author and maintainer of a variety of open-source Rust projects, including
<a href="https://github.com/LukeMathWalker/cargo-chef"><code>cargo-chef</code></a>,
<a href="https://pavex.dev">Pavex</a> and <a href="https://github.com/LukeMathWalker/wiremock-rs"><code>wiremock</code></a>.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/00_welcome"><code>01_intro/00_welcome</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<div class="warning">
<p>Don't jump ahead!<br />
Complete the exercise for the previous section before you start this one.<br />
It's located in <code>exercises/01_intro/00_welcome</code>, in the <a href="https://github.com/mainmatter/100-exercises-to-learn-rust">course GitHub's repository</a>.<br />
Use <a href="01_intro/00_welcome.html#wr-the-workshop-runner"><code>wr</code></a> to start the course and verify your solutions.</p>
</div>
<p>The previous task doesn't even qualify as an exercise, but it already exposed you to quite a bit of Rust <strong>syntax</strong>.
We won't cover every single detail of Rust's syntax used in the previous exercise.
Instead, we'll cover <em>just enough</em> to keep going without getting stuck in the details.<br />
One step at a time!</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>You can use <code>//</code> for single-line comments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a single-line comment
// Followed by another single-line comment
<span class="boring">}</span></code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions in Rust are defined using the <code>fn</code> keyword, followed by the function's name, its input parameters, and its
return type.
The function's body is enclosed in curly braces <code>{}</code>.</p>
<p>In previous exercise, you saw the <code>greeting</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` &lt;function_name&gt; ( &lt;input parameters&gt; ) -&gt; &lt;return_type&gt; { &lt;body&gt; }
fn greeting() -&gt; &amp;'static str {
    // TODO: fix me 👇
    "I'm ready to __!"
}
<span class="boring">}</span></code></pre></pre>
<p><code>greeting</code> has no input parameters and returns a reference to a string slice (<code>&amp;'static str</code>).</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>The return type can be omitted from the signature if the function doesn't return anything (i.e. if it returns <code>()</code>,
Rust's unit type).
That's what happened with the <code>test_welcome</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_welcome() {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>The above is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Spelling out the unit return type explicitly
//                   👇
fn test_welcome() -&gt; () {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h3>
<p>The last expression in a function is implicitly returned:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // This is the last expression in the function
    // Therefore its value is returned by `greeting`
    "I'm ready to learn Rust!"
}
<span class="boring">}</span></code></pre></pre>
<p>You can also use the <code>return</code> keyword to return a value early:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // Notice the semicolon at the end of the line!
    return "I'm ready to learn Rust!";
}
<span class="boring">}</span></code></pre></pre>
<p>It is considered idiomatic to omit the <code>return</code> keyword when possible.</p>
<h3 id="input-parameters"><a class="header" href="#input-parameters">Input parameters</a></h3>
<p>Input parameters are declared inside the parentheses <code>()</code> that follow the function's name.<br />
Each parameter is declared with its name, followed by a colon <code>:</code>, followed by its type.</p>
<p>For example, the <code>greet</code> function below takes a <code>name</code> parameter of type <code>&amp;str</code> (a "string slice"):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An input parameter
//        👇
fn greet(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}
<span class="boring">}</span></code></pre></pre>
<p>If there are multiple input parameters, they must be separated with commas.</p>
<h3 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h3>
<p>Since we've been mentioned "types" a few times, let's state it clearly: Rust is a <strong>statically typed language</strong>.<br />
Every single value in Rust has a type and that type must be known to the compiler at compile-time.</p>
<p>Types are a form of <strong>static analysis</strong>.<br />
You can think of a type as a <strong>tag</strong> that the compiler attaches to every value in your program. Depending on the
tag, the compiler can enforce different rules—e.g. you can't add a string to a number, but you can add two numbers
together.
If leveraged correctly, types can prevent whole classes of runtime bugs.</p>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax"><code>01_intro/01_syntax</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-calculator"><a class="header" href="#a-basic-calculator">A Basic Calculator</a></h1>
<p>In this chapter we'll learn how to use Rust as a <strong>calculator</strong>.<br />
It might not sound like much, but it'll give us a chance to cover a lot of Rust's basics, such as:</p>
<ul>
<li>How to define and call functions</li>
<li>How to declare and use variables</li>
<li>Primitive types (integers and booleans)</li>
<li>Arithmetic operators (including overflow and underflow behavior)</li>
<li>Comparison operators</li>
<li>Control flow</li>
<li>Panics</li>
</ul>
<p>Nailing the basics with a few exercises will get the language flowing under your fingers.
When we move on to more complex topics, such as traits and ownership, you'll be able to focus on the new concepts
without getting bogged down by the syntax or other trivial details.</p>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/00_intro"><code>02_basic_calculator/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-part-1"><a class="header" href="#types-part-1">Types, part 1</a></h1>
<p>In the <a href="02_basic_calculator/../01_intro/01_syntax.html">"Syntax" section</a> <code>compute</code>'s input parameters were of type <code>u32</code>.<br />
Let's unpack what that <em>means</em>.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<p><code>u32</code> is one of Rust's <strong>primitive types</strong>. Primitive types are the most basic building blocks of a language.
They're built into the language itself—i.e. they are not defined in terms of other types.</p>
<p>You can combine these primitive types to create more complex types. We'll see how soon enough.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p><code>u32</code>, in particular, is an <strong>unsigned 32-bit integer</strong>.</p>
<p>An integer is a number that can be written without a fractional component. E.g. <code>1</code> is an integer, while <code>1.2</code> is not.</p>
<h3 id="signed-vs-unsigned"><a class="header" href="#signed-vs-unsigned">Signed vs. unsigned</a></h3>
<p>An integer can be <strong>signed</strong> or <strong>unsigned</strong>.<br />
An unsigned integer can only represent non-negative numbers (i.e. <code>0</code> or greater).
A signed integer can represent both positive and negative numbers (e.g. <code>-1</code>, <code>12</code>, etc.).</p>
<p>The <code>u</code> in <code>u32</code> stands for <strong>unsigned</strong>.<br />
The equivalent type for signed integer is <code>i32</code>, where the <code>i</code> stands for integer (i.e. any integer, positive or
negative).</p>
<h3 id="bit-width"><a class="header" href="#bit-width">Bit width</a></h3>
<p>The <code>32</code> in <code>u32</code> refers to the <strong>number of bits<sup class="footnote-reference"><a href="#bit">1</a></sup></strong> used to represent the number in memory.<br />
The more bits, the larger the range of numbers that can be represented.</p>
<p>Rust supports multiple bit widths for integers: <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>.</p>
<p>With 32 bits, <code>u32</code> can represent numbers from <code>0</code> to <code>2^32 - 1</code> (a.k.a. <a href="https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX"><code>u32::MAX</code></a>).<br />
With the same number of bits, a signed integer (<code>i32</code>) can represent numbers from <code>-2^31</code> to <code>2^31 - 1</code>
(i.e. from <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN"><code>i32::MIN</code></a>
to <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX"><code>i32::MAX</code></a>).<br />
The maximum value for <code>i32</code> is smaller than the maximum value for <code>u32</code> because one bit is used to represent
the sign of the number. Check out the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>
representation for more details on how signed integers are represented in memory.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Combining the two variables (signed/unsigned and bit width), we get the following integer types:</p>
<div class="table-wrapper"><table><thead><tr><th>Bit width</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
</tbody></table>
</div>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>A <strong>literal</strong> is a notation for representing a fixed value in source code.<br />
For example, <code>42</code> is a Rust literal for the number forty-two.</p>
<h3 id="type-annotations-for-literals"><a class="header" href="#type-annotations-for-literals">Type annotations for literals</a></h3>
<p>But all values in Rust have a type, so... what's the type of <code>42</code>?</p>
<p>The Rust compiler will try to infer the type of a literal based on how it's used.<br />
If you don't provide any context, the compiler will default to <code>i32</code> for integer literals.<br />
If you want to use a different type, you can add the desired integer type as a suffix—e.g. <code>2u64</code> is a 2 that's
explicitly typed as a <code>u64</code>.</p>
<h3 id="underscores-in-literals"><a class="header" href="#underscores-in-literals">Underscores in literals</a></h3>
<p>You can use underscores <code>_</code> to improve the readability of large numbers.<br />
For example, <code>1_000_000</code> is the same as <code>1000000</code>.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic operators</a></h2>
<p>Rust supports the following arithmetic operators<sup class="footnote-reference"><a href="#traits">2</a></sup> for integers:</p>
<ul>
<li><code>+</code> for addition</li>
<li><code>-</code> for subtraction</li>
<li><code>*</code> for multiplication</li>
<li><code>/</code> for division</li>
<li><code>%</code> for remainder</li>
</ul>
<p>Precedence and associativity rules for these operators are the same as in mathematics.<br />
You can use parentheses to override the default precedence. E.g. <code>2 * (3 + 4)</code>.</p>
<blockquote>
<p>⚠️ <strong>Warning</strong></p>
<p>The division operator <code>/</code> performs integer division when used with integer types.
I.e. the result is truncated towards zero. For example, <code>5 / 2</code> is <code>2</code>, not <code>2.5</code>.</p>
</blockquote>
<h2 id="no-automatic-type-coercion"><a class="header" href="#no-automatic-type-coercion">No automatic type coercion</a></h2>
<p>As we discussed in the previous exercise, Rust is a statically typed language.<br />
In particular, Rust is quite strict about type coercion. It won't automatically convert a value from one type to
another<sup class="footnote-reference"><a href="#coercion">3</a></sup>,
even if the conversion is lossless. You have to do it explicitly.</p>
<p>For example, you can't assign a <code>u8</code> value to a variable with type <code>u32</code>, even though all <code>u8</code> values are valid <code>u32</code>
values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: u8 = 100;
let a: u32 = b;
<span class="boring">}</span></code></pre></pre>
<p>It'll throw a compilation error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
</code></pre>
<p>We'll see how to convert between types <a href="02_basic_calculator/../04_traits/09_from.html">later in this course</a>.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">The integer types section</a> in the official Rust book</li>
</ul>
<div class="footnote-definition" id="bit"><sup class="footnote-definition-label">1</sup>
<p>A bit is the smallest unit of data in a computer. It can only have two values: <code>0</code> or <code>1</code>.</p>
</div>
<div class="footnote-definition" id="traits"><sup class="footnote-definition-label">2</sup>
<p>Rust doesn't let you define custom operators, but it puts you in control of how the built-in operators
behave.
We'll talk about operator overloading <a href="02_basic_calculator/../04_traits/03_operator_overloading.html">later in the course</a>, after we've covered traits.</p>
</div>
<div class="footnote-definition" id="coercion"><sup class="footnote-definition-label">3</sup>
<p>There are some exceptions to this rule, mostly related to references, smart pointers and ergonomics. We'll
cover those <a href="02_basic_calculator/../04_traits/07_deref.html">later on</a>.
A mental model of "all conversions are explicit" will serve you well in the meantime.</p>
</div>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers"><code>02_basic_calculator/01_integers</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>In Rust, you can use the <code>let</code> keyword to declare <strong>variables</strong>.<br />
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
<span class="boring">}</span></code></pre></pre>
<p>Above we defined a variable <code>x</code> and assigned it the value <code>42</code>.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>Every variable in Rust must have a type. It can either be inferred by the compiler or explicitly specified by the
developer.</p>
<h3 id="explicit-type-annotation"><a class="header" href="#explicit-type-annotation">Explicit type annotation</a></h3>
<p>You can specify the variable type by adding a colon <code>:</code> followed by the type after the variable name. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let &lt;variable_name&gt;: &lt;type&gt; = &lt;expression&gt;;
let x: u32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we explicitly constrained the type of <code>x</code> to be <code>u32</code>.</p>
<h3 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h3>
<p>If we don't specify the type of a variable, the compiler will try to infer it based on the context in which the variable
is used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let y: u32 = x;
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we didn't specify the type of <code>x</code>.<br />
<code>x</code> is later assigned to <code>y</code>, which is explicitly typed as <code>u32</code>. Since Rust doesn't perform automatic type coercion,
the compiler infers the type of <code>x</code> to be <code>u32</code>—the same as <code>y</code> and the only type that will allow the program to compile
without errors.</p>
<h3 id="inference-limitations"><a class="header" href="#inference-limitations">Inference limitations</a></h3>
<p>The compiler sometimes needs a little help to infer the correct variable type based on its usage.<br />
In those cases you'll get a compilation error and the compiler will ask you to provide an explicit type hint to
disambiguate the situation.</p>
<h2 id="function-arguments-are-variables"><a class="header" href="#function-arguments-are-variables">Function arguments are variables</a></h2>
<p>Not all heroes wear capes, not all variables are declared with <code>let</code>.<br />
Function arguments are variables too!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one(x: u32) -&gt; u32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>In the example above, <code>x</code> is a variable of type <code>u32</code>.<br />
The only difference between <code>x</code> and a variable declared with <code>let</code> is that functions arguments <strong>must</strong> have their type
explicitly declared. The compiler won't infer it for you.<br />
This constraint allows the Rust compiler (and us humans!) to understand the function's signature without having to look
at its implementation. That's a big boost for compilation speed<sup class="footnote-reference"><a href="#speed">1</a></sup>!</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>You don't have to initialize a variable when you declare it.<br />
For example</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
<span class="boring">}</span></code></pre></pre>
<p>is a valid variable declaration.<br />
However, you must initialize the variable before using it. The compiler will throw an error if you don't:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
let y = x + 1;
<span class="boring">}</span></code></pre></pre>
<p>will throw a compilation error:</p>
<pre><code class="language-text">error[E0381]: used binding `x` isn't initialized
 --&gt; src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
</code></pre>
<div class="footnote-definition" id="speed"><sup class="footnote-definition-label">1</sup>
<p>The Rust compiler needs all the help it can get when it comes to compilation speed.</p>
</div>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables"><code>02_basic_calculator/02_variables</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-part-1"><a class="header" href="#control-flow-part-1">Control flow, part 1</a></h1>
<p>All our programs so far have been pretty straightforward.<br />
A sequence of instructions is executed from top to bottom, and that's it.</p>
<p>It's time to introduce some <strong>branching</strong>.</p>
<h2 id="if-clauses"><a class="header" href="#if-clauses"><code>if</code> clauses</a></h2>
<p>The <code>if</code> keyword is used to execute a block of code only if a condition is true.</p>
<p>Here's a simple example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number &lt; 5 {
    println!("`number` is smaller than 5");
}
<span class="boring">}</span></code></pre></pre>
<p>This program will print <code>number is smaller than 5</code> because the condition <code>number &lt; 5</code> is true.</p>
<h3 id="else-clauses"><a class="header" href="#else-clauses"><code>else</code> clauses</a></h3>
<p>Like most programming languages, Rust supports an optional <code>else</code> branch to execute a block of code when the condition in an
<code>if</code> expression is false.<br />
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;

if number &lt; 5 {
    println!("`number` is smaller than 5");
} else {
    println!("`number` is greater than or equal to 5");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>The condition in an <code>if</code> expression must be of type <code>bool</code>, a <strong>boolean</strong>.<br />
Booleans, just like integers, are a primitive type in Rust.</p>
<p>A boolean can have one of two values: <code>true</code> or <code>false</code>.</p>
<h3 id="no-truthy-or-falsy-values"><a class="header" href="#no-truthy-or-falsy-values">No truthy or falsy values</a></h3>
<p>If the condition in an <code>if</code> expression is not a boolean, you'll get a compilation error.</p>
<p>For example, the following code will not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number {
    println!("`number` is not zero");
}
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following compilation error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:8
  |
3 |     if number {
  |        ^^^^^^ expected `bool`, found integer
</code></pre>
<p>This follows from Rust's philosophy around type coercion: there's no automatic conversion from non-boolean types to booleans.
Rust doesn't have the concept of <strong>truthy</strong> or <strong>falsy</strong> values, like JavaScript or Python.<br />
You have to be explicit about the condition you want to check.</p>
<h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison operators</a></h3>
<p>It's quite common to use comparison operators to build conditions for <code>if</code> expressions.<br />
Here are the comparison operators available in Rust when working with integers:</p>
<ul>
<li><code>==</code>: equal to</li>
<li><code>!=</code>: not equal to</li>
<li><code>&lt;</code>: less than</li>
<li><code>&gt;</code>: greater than</li>
<li><code>&lt;=</code>: less than or equal to</li>
<li><code>&gt;=</code>: greater than or equal to</li>
</ul>
<h2 id="ifelse-is-an-expression"><a class="header" href="#ifelse-is-an-expression"><code>if/else</code> is an expression</a></h2>
<p>In Rust, <code>if</code> expressions are <strong>expressions</strong>, not statements: they return a value.<br />
That value can be assigned to a variable or used in other expressions. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
let message = if number &lt; 5 {
    "smaller than 5"
} else {
    "greater than or equal to 5"
};
<span class="boring">}</span></code></pre></pre>
<p>In the example above, each branch of the <code>if</code> evaluates to a string literal,
which is then assigned to the <code>message</code> variable.<br />
The only requirement is that both <code>if</code> branches return the same type.</p>
<h2 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/03_if_else"><code>02_basic_calculator/03_if_else</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">Panics</a></h1>
<p>Let's go back to the <code>speed</code> function you wrote for the <a href="02_basic_calculator/02_variables.html">"Variables" section</a>.
It probably looked something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn speed(start: u32, end: u32, time_elapsed: u32) -&gt; u32 {
    let distance = end - start;
    distance / time_elapsed
}
<span class="boring">}</span></code></pre></pre>
<p>If you have a keen eye, you might have spotted one issue<sup class="footnote-reference"><a href="#one">1</a></sup>: what happens if <code>time_elapsed</code> is zero?</p>
<p>You can try it
out <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36e5ddbe3b3f741dfa9f74c956622bac">on the Rust playground</a>!<br />
The program will exit with the following error message:</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:3:5:
attempt to divide by zero
</code></pre>
<p>This is known as a <strong>panic</strong>.<br />
A panic is Rust's way to signal that something went so wrong that
the program can't continue executing, it's an <strong>unrecoverable error</strong><sup class="footnote-reference"><a href="#catching">2</a></sup>. Division by zero classifies as such an
error.</p>
<h2 id="the-panic-macro"><a class="header" href="#the-panic-macro">The panic! macro</a></h2>
<p>You can intentionally trigger a panic by calling the <code>panic!</code> macro<sup class="footnote-reference"><a href="#macro">3</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("This is a panic!");
    // The line below will never be executed
    let x = 1 + 2;
}</code></pre></pre>
<p>There are other mechanisms to work with recoverable errors in Rust, which <a href="02_basic_calculator/../05_ticket_v2/06_fallibility.html">we'll cover later</a>.
For the time being we'll stick with panics as a brutal but simple stopgap solution.</p>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.panic.html">The panic! macro documentation</a></li>
</ul>
<div class="footnote-definition" id="one"><sup class="footnote-definition-label">1</sup>
<p>There's another issue with <code>speed</code> that we'll address soon enough. Can you spot it?</p>
</div>
<div class="footnote-definition" id="catching"><sup class="footnote-definition-label">2</sup>
<p>You can try to catch a panic, but it should be a last resort attempt reserved for very specific
circumstances.</p>
</div>
<div class="footnote-definition" id="macro"><sup class="footnote-definition-label">3</sup>
<p>If it's followed by a <code>!</code>, it's a macro invocation. Think of macros as spicy functions for now. We'll
cover them in more detail later in the course.</p>
</div>
<h2 id="exercise-6"><a class="header" href="#exercise-6">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/04_panics"><code>02_basic_calculator/04_panics</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial"><a class="header" href="#factorial">Factorial</a></h1>
<p>So far you've learned:</p>
<ul>
<li>How to define a function</li>
<li>How to call a function</li>
<li>Which integer types are available in Rust</li>
<li>Which arithmetic operators are available for integers</li>
<li>How to execute conditional logic via comparisons and <code>if</code>/<code>else</code> expressions</li>
</ul>
<p>It looks like you're ready to tackle factorials!</p>
<h2 id="exercise-7"><a class="header" href="#exercise-7">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/05_factorial"><code>02_basic_calculator/05_factorial</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-1-while"><a class="header" href="#loops-part-1-while">Loops, part 1: <code>while</code></a></h1>
<p>Your implementation of <code>factorial</code> has been forced to use recursion.<br />
This may feel natural to you, especially if you're coming from a functional programming background.
Or it may feel strange, if you're used to more imperative languages like C or Python.</p>
<p>Let's see how you can implement the same functionality using a <strong>loop</strong> instead.</p>
<h2 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> loop</a></h2>
<p>A <code>while</code> loop is a way to execute a block of code as long as a <strong>condition</strong> is true.<br />
Here's the general syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while &lt;condition&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<p>For example, we might want to sum the numbers from 1 to 5:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0;
let i = 1;
// "while i is less than or equal to 5"
while i &lt;= 5 {
    // `+=` is a shorthand for `sum = sum + i`
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will keep adding 1 to <code>i</code> and <code>i</code> to <code>sum</code> until <code>i</code> is no longer less than or equal to 5.</p>
<h2 id="the-mut-keyword"><a class="header" href="#the-mut-keyword">The <code>mut</code> keyword</a></h2>
<p>The example above won't compile as is. You'll get an error like:</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `sum`
 --&gt; src/main.rs:7:9
  |
2 |     let sum = 0;
  |         ---
  |         |
  |         first assignment to `sum`
  |         help: consider making this binding mutable: `mut sum`
...
7 |         sum += i;
  |         ^^^^^^^^ cannot assign twice to immutable variable

error[E0384]: cannot assign twice to immutable variable `i`
 --&gt; src/main.rs:8:9
  |
3 |     let i = 1;
  |         -
  |         |
  |         first assignment to `i`
  |         help: consider making this binding mutable: `mut i`
...
8 |         i += 1;
  |         ^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>This is because variables in Rust are <strong>immutable</strong> by default.<br />
You can't change their value once it has been assigned.</p>
<p>If you want to allow modifications, you have to declare the variable as <strong>mutable</strong> using the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `sum` and `i` are mutable now!
let mut sum = 0;
let mut i = 1;

while i &lt;= 5 {
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This will compile and run without errors.</p>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.while.html"><code>while</code> loop documentation</a></li>
</ul>
<h2 id="exercise-8"><a class="header" href="#exercise-8">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/06_while"><code>02_basic_calculator/06_while</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-part-2-for"><a class="header" href="#loops-part-2-for">Loops, part 2: <code>for</code></a></h1>
<p>Having to manually increment a counter variable is somewhat tedious. The pattern is also extremely common!<br />
To make this easier, Rust provides a more concise way to iterate over a range of values: the <code>for</code> loop.</p>
<h2 id="the-for-loop"><a class="header" href="#the-for-loop">The <code>for</code> loop</a></h2>
<p>A <code>for</code> loop is a way to execute a block of code for each element in an iterator<sup class="footnote-reference"><a href="#iterator">1</a></sup>.</p>
<p>Here's the general syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for &lt;element&gt; in &lt;iterator&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ranges"><a class="header" href="#ranges">Ranges</a></h2>
<p>Rust's standard library provides <strong>range</strong> type that can be used to iterate over a sequence of numbers<sup class="footnote-reference"><a href="#weird-ranges">2</a></sup>.</p>
<p>For example, if we want to sum the numbers from 1 to 5:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..=5 {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<p>Every time the loop runs, <code>i</code> will be assigned the next value in the range before executing the block of code.</p>
<p>There are five kinds of ranges in Rust:</p>
<ul>
<li><code>1..5</code>: A (half-open) range. It includes all numbers from 1 to 4. It doesn't include the last value, 5.</li>
<li><code>1..=5</code>: An inclusive range. It includes all numbers from 1 to 5. It includes the last value, 5.</li>
<li><code>1..</code>: An open-ended range. It includes all numbers from 1 to infinity (well, until the maximum value of the integer type).</li>
<li><code>..5</code>: A range that starts at the minimum value for the integer type and ends at 4. It doesn't include the last value, 5.</li>
<li><code>..=5</code>: A range that starts at the minimum value for the integer type and ends at 5. It includes the last value, 5.</li>
</ul>
<p>You can use a <code>for</code> loop with the first three kinds of ranges, where the starting point
is explicitly specified. The last two range types are used in other contexts, that we'll cover later.</p>
<p>The extreme values of a range don't have to be integer literals—they can be variables or expressions too!</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end = 5;
let mut sum = 0;

for i in 1..(end + 1) {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop documentation</a></li>
</ul>
<div class="footnote-definition" id="iterator"><sup class="footnote-definition-label">1</sup>
<p>Later in the course we'll give a precise definition of what counts as an "iterator".
For now, think of it as a sequence of values that you can loop over.</p>
</div>
<div class="footnote-definition" id="weird-ranges"><sup class="footnote-definition-label">2</sup>
<p>You can use ranges with other types too (e.g. characters and IP addresses),
but integers are definitely the most common case in day-to-day Rust programming.</p>
</div>
<h2 id="exercise-9"><a class="header" href="#exercise-9">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/07_for"><code>02_basic_calculator/07_for</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow"><a class="header" href="#overflow">Overflow</a></h1>
<p>The factorial of a number grows quite fast.<br />
For example, the factorial of 20 is 2,432,902,008,176,640,000. That's already bigger than the maximum value for a
32-bit integer, 2,147,483,647.</p>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type,
we are talking about <strong>an integer overflow</strong>.</p>
<p>Integer overflows are an issue because they violate the contract for arithmetic operations.<br />
The result of an arithmetic operation between two integers of a given type should be another integer of the same type.
But the <em>mathematically correct result</em> doesn't fit into that integer type!</p>
<blockquote>
<p>If the result is smaller than the minimum value for a given integer type, we refer to the event as <strong>an integer
underflow</strong>.<br />
For brevity, we'll only talk about integer overflows for the rest of this section, but keep in mind that
everything we say applies to integer underflows as well.</p>
<p>The <code>speed</code> function you wrote in the <a href="02_basic_calculator/02_variables.html">"Variables" section</a> underflowed for some input
combinations.
E.g. if <code>end</code> is smaller than <code>start</code>, <code>end - start</code> will underflow the <code>u32</code> type since the result is supposed
to be negative but <code>u32</code> can't represent negative numbers.</p>
</blockquote>
<h2 id="no-automatic-promotion"><a class="header" href="#no-automatic-promotion">No automatic promotion</a></h2>
<p>One possible approach would be automatically promote the result to a bigger integer type.
E.g. if you're summing two <code>u8</code> integers and the result is 256 (<code>u8::MAX + 1</code>), Rust could choose to interpret the
result as <code>u16</code>, the next integer type that's big enough to hold 256.</p>
<p>But, as we've discussed before, Rust is quite picky about type conversions. Automatic integer promotion
is not Rust's solution to the integer overflow problem.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Since we ruled out automatic promotion, what can we do when an integer overflow occurs?<br />
It boils down to two different approaches:</p>
<ul>
<li>Reject the operation</li>
<li>Come up with a "sensible" result that fits into the expected integer type</li>
</ul>
<h3 id="reject-the-operation"><a class="header" href="#reject-the-operation">Reject the operation</a></h3>
<p>This is the most conservative approach: we stop the program when an integer overflow occurs.<br />
That's done via a panic, the mechanism we've already seen in the <a href="02_basic_calculator/04_panics.html">"Panics" section</a>.</p>
<h3 id="come-up-with-a-sensible-result"><a class="header" href="#come-up-with-a-sensible-result">Come up with a "sensible" result</a></h3>
<p>When the result of an arithmetic operation is bigger than the maximum value for a given integer type, you can
choose to <strong>wrap around</strong>.<br />
If you think of all the possible values for a given integer type as a circle, wrapping around means that when you
reach the maximum value, you start again from the minimum value.</p>
<p>For example, if you do a <strong>wrapping addition</strong> between 1 and 255 (=<code>u8::MAX</code>), the result is 0 (=<code>u8::MIN</code>).
If you're working with signed integers, the same principle applies. E.g. adding 1 to 127 (=<code>i8::MAX</code>) with wrapping
will give you -128 (=<code>i8::MIN</code>).</p>
<h2 id="overflow-checks"><a class="header" href="#overflow-checks"><code>overflow-checks</code></a></h2>
<p>Rust lets you, the developer, choose which approach to use when an integer overflow occurs.
The behaviour is controlled by the <code>overflow-checks</code> profile setting.</p>
<p>If <code>overflow-checks</code> is set to <code>true</code>, Rust will <strong>panic at runtime</strong> when an integer operation overflows.
If <code>overflow-checks</code> is set to <code>false</code>, Rust will <strong>wrap around</strong> when an integer operation overflows.</p>
<p>You may be wondering—what is a profile setting? Let's get into that!</p>
<h2 id="profiles"><a class="header" href="#profiles">Profiles</a></h2>
<p>A <a href="https://doc.rust-lang.org/cargo/reference/profiles.html"><strong>profile</strong></a> is a set of configuration options that can be
used to customize the way Rust code is compiled.</p>
<p>Cargo provides two built-in profiles: <code>dev</code> and <code>release</code>.<br />
The <code>dev</code> profile is used every time you run <code>cargo build</code>, <code>cargo run</code> or <code>cargo test</code>. It's aimed at local
development,
therefore it sacrifices runtime performance in favor of faster compilation times and a better debugging experience.<br />
The <code>release</code> profile, instead, is optimized for runtime performance but incurs longer compilation times. You need
to explicitly request via the <code>--release</code> flag—e.g. <code>cargo build --release</code> or <code>cargo run --release</code>.</p>
<blockquote>
<p>"Have you built your project in release mode?" is almost a meme in the Rust community.<br />
It refers to developers who are not familiar with Rust and complain about its performance on
social media (e.g. Reddit, Twitter, etc.) before realizing they haven't built their project in
release mode.</p>
</blockquote>
<p>You can also define custom profiles or customize the built-in ones.</p>
<h3 id="overflow-check"><a class="header" href="#overflow-check"><code>overflow-check</code></a></h3>
<p>By default, <code>overflow-checks</code> is set to:</p>
<ul>
<li><code>true</code> for the <code>dev</code> profile</li>
<li><code>false</code> for the <code>release</code> profile</li>
</ul>
<p>This is in line with the goals of the two profiles.<br />
<code>dev</code> is aimed at local development, so it panics in order to highlight potential issues as early as possible.<br />
<code>release</code>, instead, is tuned for runtime performance: checking for overflows would slow down the program, so it
prefers to wrap around.</p>
<p>At the same time, having different behaviours for the two profiles can lead to subtle bugs.<br />
Our recommendation is to enable <code>overflow-checks</code> for both profiles: it's better to crash than to silently produce
incorrect results. The runtime performance hit is negligible in most cases; if you're working on a performance-critical
application, you can run benchmarks to decide if it's something you can afford.</p>
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further reading</a></h2>
<ul>
<li>Check out <a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">"Myths and legends about integer overflow in Rust"</a>
for an in-depth discussion about integer overflow in Rust.</li>
</ul>
<h2 id="exercise-10"><a class="header" href="#exercise-10">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow"><code>02_basic_calculator/08_overflow</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-by-case-behavior"><a class="header" href="#case-by-case-behavior">Case-by-case behavior</a></h1>
<p><code>overflow-checks</code> is a blunt tool: it's a global setting that affects the whole program.<br />
It often happens that you want to handle integer overflows differently depending on the context: sometimes
wrapping is the right choice, other times panicking is preferable.</p>
<h2 id="wrapping_-methods"><a class="header" href="#wrapping_-methods"><code>wrapping_</code> methods</a></h2>
<p>You can opt into wrapping arithmetic on a per-operation basis by using the <code>wrapping_</code> methods<sup class="footnote-reference"><a href="#method">1</a></sup>.<br />
For example, you can use <code>wrapping_add</code> to add two integers with wrapping:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);
<span class="boring">}</span></code></pre></pre>
<h2 id="saturating_-methods"><a class="header" href="#saturating_-methods"><code>saturating_</code> methods</a></h2>
<p>Alternatively, you can opt into <strong>saturating arithmetic</strong> by using the <code>saturating_</code> methods.<br />
Instead of wrapping around, saturating arithmetic will return the maximum or minimum value for the integer type.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.saturating_add(y);
assert_eq!(sum, 255);
<span class="boring">}</span></code></pre></pre>
<p>Since <code>255 + 1</code> is <code>256</code>, which is bigger than <code>u8::MAX</code>, the result is <code>u8::MAX</code> (255).<br />
The opposite happens for underflows: <code>0 - 1</code> is <code>-1</code>, which is smaller than <code>u8::MIN</code>, so the result is <code>u8::MIN</code> (0).</p>
<p>You can't get saturating arithmetic via the <code>overflow-checks</code> profile setting—you have to explicitly opt into it
when performing the arithmetic operation.</p>
<div class="footnote-definition" id="method"><sup class="footnote-definition-label">1</sup>
<p>You can think of methods as functions that are "attached" to a specific type.
We'll cover methods (and how to define them) in the next chapter.</p>
</div>
<h2 id="exercise-11"><a class="header" href="#exercise-11">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating"><code>02_basic_calculator/09_saturating</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversions-pt-1"><a class="header" href="#conversions-pt-1">Conversions, pt. 1</a></h1>
<p>We've repeated over and over again that Rust won't perform
implicit type conversions for integers.<br />
How do you perform <em>explicit</em> conversions then?</p>
<h2 id="as"><a class="header" href="#as"><code>as</code></a></h2>
<p>You can use the <code>as</code> operator to convert between integer types.<br />
<code>as</code> conversions are <strong>infallible</strong>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u32 = 10;

// Cast `a` into the `u64` type
let b = a as u64;

// You can use `_` as the target type
// if it can be correctly inferred 
// by the compiler. For example:
let c: u64 = a as _;
<span class="boring">}</span></code></pre></pre>
<p>The semantics of this conversion are what you expect: all <code>u32</code> values are valid <code>u64</code>
values.</p>
<h3 id="truncation"><a class="header" href="#truncation">Truncation</a></h3>
<p>Things get more interesting if we go in the opposite direction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A number that's too big 
// to fit into a `u8`
let a: u16 = 255 + 1;
let b = a as u8;
<span class="boring">}</span></code></pre></pre>
<p>This program will run without issues, because <code>as</code> conversions are infallible.
But what is the value of <code>b</code>?
When going from a larger integer type to a smaller, the Rust compiler will perform
a <strong>truncation</strong>.</p>
<p>To understand what happens, let's start by looking at how <code>256u16</code> is
represented in memory, as a sequence of bits:</p>
<pre><code class="language-text"> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
|               |               |
+---------------+---------------+
  First 8 bits    Last 8 bits
</code></pre>
<p>When converting to a <code>u8</code>, the Rust compiler will keep the last 8 bits of a <code>u16</code>
memory representation:</p>
<pre><code class="language-text"> 0 0 0 0 0 0 0 0 
|               |
+---------------+
  Last 8 bits
</code></pre>
<p>Hence <code>256 as u8</code> is equal to <code>0</code>. That's... not ideal, in most scenarios.<br />
In fact, the Rust compiler will actively try to stop you if it sees you trying
to cast a literal value which will result in a truncation:</p>
<pre><code class="language-text">error: literal out of range for `i8`
  |
4 |     let a = 255 as i8;
  |             ^^^
  |
  = note: the literal `255` does not fit into the type `i8` whose range is `-128..=127`
  = help: consider using the type `u8` instead
  = note: `#[deny(overflowing_literals)]` on by default
</code></pre>
<h3 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h3>
<p>As a rule of thumb, be quite careful with <code>as</code> casting.<br />
Use it <em>exclusively</em> for going from a smaller type to a larger type.
To convert from a larger to smaller integer type, rely on the
<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html"><em>fallible</em> conversion machinery</a> that we'll
explore later in the course.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Surprising behaviour is not the only downside of <code>as</code> casting.
It is also fairly limited: you can only rely on <code>as</code> casting
for primitive types and a few other special cases.<br />
When working with composite types, you'll have to rely on
different conversion mechanisms (<a href="02_basic_calculator/../05_ticket_v2/13_try_from.html">fallible</a>
and <a href="02_basic_calculator/../04_traits/09_from.html">infallible</a>), which we'll explore later on.</p>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further reading</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#numeric-cast">Rust's official reference</a>
to learn the precise behaviour of <code>as</code> casting for each source/target combination,
as well as the exhaustive list of allowed conversions.</li>
</ul>
<h2 id="exercise-12"><a class="header" href="#exercise-12">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/10_as_casting"><code>02_basic_calculator/10_as_casting</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticket"><a class="header" href="#modelling-a-ticket">Modelling A Ticket</a></h1>
<p>The first chapter should have given you a good grasp over some of Rust's primitive types, operators and
basic control flow constructs.<br />
In this chapter we'll go one step further and cover what makes Rust truly unique: <strong>ownership</strong>.<br />
Ownership is what enables Rust to be both memory-safe and performant, with no garbage collector.</p>
<p>As our running example, we'll use a (JIRA-like) ticket, the kind you'd use to track bugs, features, or tasks in
a software project.<br />
We'll take a stab at modeling it in Rust. It'll be the first iteration—it won't be perfect nor very idiomatic
by the end of the chapter. It'll be enough of a challenge though!<br />
To move forward you'll have to pick up several new Rust concepts, such as:</p>
<ul>
<li><code>struct</code>s, one of Rust's ways to define custom types</li>
<li>Ownership, references and borrowing</li>
<li>Memory management: stack, heap, pointers, data layout, destructors</li>
<li>Modules and visibility</li>
<li>Strings</li>
</ul>
<h2 id="exercise-13"><a class="header" href="#exercise-13">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/00_intro"><code>03_ticket_v1/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>We need to keep track of three pieces of information for each ticket:</p>
<ul>
<li>A title</li>
<li>A description</li>
<li>A status</li>
</ul>
<p>We can start by using a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
to represent them. <code>String</code> is the type defined in Rust's standard library to represent
<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded</a> text.</p>
<p>But how do we <strong>combine</strong> these three pieces of information into a single entity?</p>
<h2 id="defining-a-struct"><a class="header" href="#defining-a-struct">Defining a <code>struct</code></a></h2>
<p>A <code>struct</code> defines a <strong>new Rust type</strong>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>A struct is quite similar to what you would call a class or an object in other programming languages.</p>
<h2 id="defining-fields"><a class="header" href="#defining-fields">Defining fields</a></h2>
<p>The new type is built by combining other types as <strong>fields</strong>.<br />
Each field must have a name and a type, separated by a colon, <code>:</code>. If there are multiple fields, they are separated by a comma, <code>,</code>.</p>
<p>Fields don't have to be of the same type, as you can see in the <code>Configuration</code> struct below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
   version: u32,
   active: bool
}
<span class="boring">}</span></code></pre></pre>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>You can create an instance of a struct by specifying the values for each field:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Syntax: &lt;StructName&gt; { &lt;field_name&gt;: &lt;value&gt;, ... }
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-fields"><a class="header" href="#accessing-fields">Accessing fields</a></h2>
<p>You can access the fields of a struct using the <code>.</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Field access
let x = ticket.description;
<span class="boring">}</span></code></pre></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>We can attach behaviour to our structs by defining <strong>methods</strong>.<br />
Using the <code>Ticket</code> struct as an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    fn is_open(self) -&gt; bool {
        self.status == "Open"
    }
}

// Syntax:
// impl &lt;StructName&gt; {
//    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
//        // Method body
//    }
// }
<span class="boring">}</span></code></pre></pre>
<p>Methods are pretty similar to functions, with two key differences:</p>
<ol>
<li>methods must be defined inside an <strong><code>impl</code> block</strong></li>
<li>methods may use <code>self</code> as their first parameter.
<code>self</code> is a keyword and represents the instance of the struct the method is being called on.</li>
</ol>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p>If a method takes <code>self</code> as its first parameter, it can be called using the <strong>method call syntax</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Method call syntax: &lt;instance&gt;.&lt;method_name&gt;(&lt;parameters&gt;)
let is_open = ticket.is_open();
<span class="boring">}</span></code></pre></pre>
<p>This is the same calling syntax you used to perform saturating arithmetic operations on <code>u32</code> values
in <a href="03_ticket_v1/../02_basic_calculator/09_saturating.html">the previous chapter</a>.</p>
<h3 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h3>
<p>If a method doesn't take <code>self</code> as its first parameter, it's a <strong>static method</strong>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
    version: u32,
    active: bool
}

impl Configuration {
    // `default` is a static method on `Configuration`
    fn default() -&gt; Configuration {
        Configuration { version: 0, active: false }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The only way to call a static method is by using the <strong>function call syntax</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;parameters&gt;)
let default_config = Configuration::default();
<span class="boring">}</span></code></pre></pre>
<h3 id="equivalence"><a class="header" href="#equivalence">Equivalence</a></h3>
<p>You can use the function call syntax even for methods that take <code>self</code> as their first parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;instance&gt;, &lt;parameters&gt;)
let is_open = Ticket::is_open(ticket);
<span class="boring">}</span></code></pre></pre>
<p>The function call syntax makes it quite clear that <code>ticket</code> is being used as <code>self</code>, the first parameter of the method,
but it's definitely more verbose. Prefer the method call syntax when possible.</p>
<h2 id="exercise-14"><a class="header" href="#exercise-14">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct"><code>03_ticket_v1/01_struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>Let's go back to our ticket definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We are using "raw" types for the fields of our <code>Ticket</code> struct.
This means that users can create a ticket with an empty title, a suuuuuuuper long description or
a nonsensical status (e.g. "Funny").<br />
We can do better than that!</p>
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further reading</a></h2>
<ul>
<li>Check out <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>'s documentation</a>
for a thorough overview of the methods it provides. You'll need it for the exercise!</li>
</ul>
<h2 id="exercise-15"><a class="header" href="#exercise-15">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/02_validation"><code>03_ticket_v1/02_validation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>The <code>new</code> method you've just defined is trying to enforce some <strong>constraints</strong> on the field values for <code>Ticket</code>.
But are those invariants really enforced? What prevents a developer from creating a <code>Ticket</code>
without going through <code>Ticket::new</code>?</p>
<p>To get proper <strong>encapsulation</strong> you need to become familiar with two new concepts: <strong>visibility</strong> and <strong>modules</strong>.
Let's start with modules.</p>
<h2 id="what-is-a-module"><a class="header" href="#what-is-a-module">What is a module?</a></h2>
<p>In Rust a <strong>module</strong> is a way to group related code together, under a common namespace (i.e. the module's name).<br />
You've already seen modules in action: the unit tests that verify the correctness of your code are defined in a
different module, named <code>tests</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="inline-modules"><a class="header" href="#inline-modules">Inline modules</a></h2>
<p>The <code>tests</code> module above is an example of an <strong>inline module</strong>: the module declaration (<code>mod tests</code>) and the module
contents (the stuff inside <code>{ ... }</code>) are next to each other.</p>
<h2 id="module-tree"><a class="header" href="#module-tree">Module tree</a></h2>
<p>Modules can be nested, forming a <strong>tree</strong> structure.<br />
The root of the tree is the <strong>crate</strong> itself, which is the top-level module that contains all the other modules.
For a library crate, the root module is usually <code>src/lib.rs</code> (unless its location has been customized).
The root module is also known as the <strong>crate root</strong>.</p>
<p>The crate root can have submodules, which in turn can have their own submodules, and so on.</p>
<h2 id="external-modules-and-the-filesystem"><a class="header" href="#external-modules-and-the-filesystem">External modules and the filesystem</a></h2>
<p>Inline modules are useful for small pieces of code, but as your project grows you'll want to split your code into
multiple files. In the parent module, you declare the existence of a submodule using the <code>mod</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod dog;
<span class="boring">}</span></code></pre></pre>
<p><code>cargo</code>, Rust's build tool, is then in charge of finding the file that contains
the module implementation.<br />
If your module is declared in the root of your crate (e.g. <code>src/lib.rs</code> or <code>src/main.rs</code>),
<code>cargo</code> expects the file to be named either:</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<p>If your module is a submodule of another module, the file should be named:</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<p>E.g. <code>src/animals/dog.rs</code> or <code>src/animals/dog/mod.rs</code> if <code>dog</code> is a submodule of <code>animals</code>.</p>
<p>Your IDE might help you create these files automatically when you declare a new module using the <code>mod</code> keyword.</p>
<h2 id="item-paths-and-use-statements"><a class="header" href="#item-paths-and-use-statements">Item paths and <code>use</code> statements</a></h2>
<p>You can access items defined in the same module without any special syntax. You just use their name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    // [...]
}

// No need to qualify `Ticket` in any way here
// because we're in the same module
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>That's not the case if you want to access an entity from a different module.<br />
You have to use a <strong>path</strong> pointing to the entity you want to access.</p>
<p>You can compose the path in various ways:</p>
<ul>
<li>starting from the root of the current crate, e.g. <code>crate::module_1::module_2::MyStruct</code></li>
<li>starting from the parent module, e.g. <code>super::my_function</code></li>
<li>starting from the current module, e.g. <code>sub_module_1::MyStruct</code></li>
</ul>
<p>Having to write the full path every time you want to refer to a type can be cumbersome.
To make your life easier, you can introduce a <code>use</code> statement to bring the entity into scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bring `MyStruct` into scope
use crate::module_1::module_2::MyStruct;

// Now you can refer to `MyStruct` directly
fn a_function(s: MyStruct) {
     // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="star-imports"><a class="header" href="#star-imports">Star imports</a></h3>
<p>You can also import all the items from a module with a single <code>use</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::module_1::module_2::*;
<span class="boring">}</span></code></pre></pre>
<p>This is known as a <strong>star import</strong>.<br />
It is generally discouraged because it can pollute the current namespace, making it hard to understand
where each name comes from and potentially introducing name conflicts.<br />
Nonetheless, it can be useful in some cases, like when writing unit tests. You might have noticed
that most of our test modules start with a <code>use super::*;</code> statement to bring all the items from the parent module
(the one being tested) into scope.</p>
<h2 id="exercise-16"><a class="header" href="#exercise-16">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules"><code>03_ticket_v1/03_modules</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>When you start breaking down your code into multiple modules, you need to start thinking about <strong>visibility</strong>.
Visibility determines which regions of your code (or other people's code) can access a given entity,
be it a struct, a function, a field, etc.</p>
<h2 id="private-by-default"><a class="header" href="#private-by-default">Private by default</a></h2>
<p>By default, everything in Rust is <strong>private</strong>.<br />
A private entity can only be accessed:</p>
<ol>
<li>within the same module where it's defined, or</li>
<li>by one of its submodules</li>
</ol>
<p>We've used this extensively in the previous exercises:</p>
<ul>
<li><code>create_todo_ticket</code> worked (once you added a <code>use</code> statement) because <code>helpers</code> is a submodule of the crate root,
where <code>Ticket</code> is defined. Therefore, <code>create_todo_ticket</code> can access <code>Ticket</code> without any issues even
though <code>Ticket</code> is private.</li>
<li>All our unit tests are defined in a submodule of the code they're testing, so they can access everything without
restrictions.</li>
</ul>
<h2 id="visibility-modifiers"><a class="header" href="#visibility-modifiers">Visibility modifiers</a></h2>
<p>You can modify the default visibility of an entity using a <strong>visibility modifier</strong>.<br />
Some common visibility modifiers are:</p>
<ul>
<li><code>pub</code>: makes the entity <strong>public</strong>, i.e. accessible from outside the module where it's defined, potentially from
other crates.</li>
<li><code>pub(crate)</code>: makes the entity public within the same <strong>crate</strong>, but not outside of it.</li>
<li><code>pub(super)</code>: makes the entity public within the parent module.</li>
<li><code>pub(in path::to::module)</code>: makes the entity public within the specified module.</li>
</ul>
<p>You can use these modifiers on modules, structs, functions, fields, etc.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Configuration {
    pub(crate) version: u32,
    active: bool,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Configuration</code> is public, but you can only access the <code>version</code> field from within the same crate.
The <code>active</code> field, instead, is private and can only be accessed from within the same module or one of its submodules.</p>
<h2 id="exercise-17"><a class="header" href="#exercise-17">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/04_visibility"><code>03_ticket_v1/04_visibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h1>
<p>Now that we have a basic understanding of modules and visibility, let's circle back to <strong>encapsulation</strong>.<br />
Encapsulation is the practice of hiding the internal representation of an object. It is most commonly
used to enforce some <strong>invariants</strong> on the object's state.</p>
<p>Going back to our <code>Ticket</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>If all fields are made public, there is no encapsulation.<br />
You must assume that the fields can be modified at any time, set to any value that's allowed by
their type. You can't rule out that a ticket might have an empty title or a status
that doesn't make sense.</p>
<p>To enforce stricter rules, we must keep the fields private<sup class="footnote-reference"><a href="#newtype">1</a></sup>.
We can then provide public methods to interact with a <code>Ticket</code> instance.
Those public methods will have the responsibility of upholding our invariants (e.g. a title must not be empty).</p>
<p>If all fields are private, it is no longer possible to create a <code>Ticket</code> instance directly using the struct
instantiation syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't work!
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};
<span class="boring">}</span></code></pre></pre>
<p>You've seen this in action in the previous exercise on visibility.<br />
We now need to provide one or more public <strong>constructors</strong>—i.e. static methods or functions that can be used
from outside the module to create a new instance of the struct.<br />
Luckily enough we already have one: <code>Ticket::new</code>, as implemented in <a href="03_ticket_v1/02_validation.html">a previous exercise</a>.</p>
<h2 id="accessor-methods"><a class="header" href="#accessor-methods">Accessor methods</a></h2>
<p>In summary:</p>
<ul>
<li>All <code>Ticket</code> fields are private</li>
<li>We provide a public constructor, <code>Ticket::new</code>, that enforces our validation rules on creation</li>
</ul>
<p>That's a good start, but it's not enough: apart from creating a <code>Ticket</code>, we also need to interact with it.
But how can we access the fields if they're private?</p>
<p>We need to provide <strong>accessor methods</strong>.<br />
Accessor methods are public methods that allow you to read the value of a private field (or fields) of a struct.</p>
<p>Rust doesn't have a built-in way to generate accessor methods for you, like some other languages do.
You have to write them yourself—they're just regular methods.</p>
<div class="footnote-definition" id="newtype"><sup class="footnote-definition-label">1</sup>
<p>Or refine their type, a technique we'll explore <a href="03_ticket_v1/../05_ticket_v2/15_outro.html">later on</a>.</p>
</div>
<h2 id="exercise-18"><a class="header" href="#exercise-18">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation"><code>03_ticket_v1/05_encapsulation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>If you solved the previous exercise using what this course has taught you so far,
your accessor methods probably look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(self) -&gt; String {
        self.title
    }

    pub fn description(self) -&gt; String {
        self.description
    }

    pub fn status(self) -&gt; String {
        self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Those methods compile and are enough to get tests to pass, but in a real-world scenario they won't get you very far.
Consider this snippet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ticket.status() == "To-Do" {
    // We haven't covered the `println!` macro yet,
    // but for now it's enough to know that it prints 
    // a (templated) message to the console
    println!("Your next task is: {}", ticket.title());
}
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile it, you'll get an error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`, 
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>Congrats, this is your first borrow-checker error!</p>
<h2 id="the-perks-of-rusts-ownership-system"><a class="header" href="#the-perks-of-rusts-ownership-system">The perks of Rust's ownership system</a></h2>
<p>Rust's ownership system is designed to ensure that:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
<li>Data is never accessed after it has been destroyed</li>
</ul>
<p>These constraints are enforced by the <strong>borrow checker</strong>, a subsystem of the Rust compiler,
often the subject of jokes and memes in the Rust community.</p>
<p>Ownership is a key concept in Rust, and it's what makes the language unique.
Ownership enables Rust to provide <strong>memory safety without compromising performance</strong>.
All these things are true at the same time for Rust:</p>
<ol>
<li>There is no runtime garbage collector</li>
<li>As a developer, you rarely have to manage memory directly</li>
<li>You can't cause dangling pointers, double frees, and other memory-related bugs</li>
</ol>
<p>Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.<br />
Language like C or C++ give you 1., but neither 2. nor 3.</p>
<p>Depending on your background, 3. might sound a bit arcane: what is a "dangling pointer"?
What is a "double free"? Why are they dangerous?<br />
Don't worry: we'll cover these concepts in more details during the rest of the course.</p>
<p>For now, though, let's focus on learning how to work within Rust's ownership system.</p>
<h2 id="the-owner"><a class="header" href="#the-owner">The owner</a></h2>
<p>In Rust, each value has an <strong>owner</strong>, statically determined at compile-time.
There is only one owner for each value at any given time.</p>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move semantics</a></h2>
<p>Ownership can be transferred.</p>
<p>If you own a value, for example, you can transfer ownership to another variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 42; // &lt;--- `a` is the owner of the value `42`
let b = a;  // &lt;--- `b` is now the owner of the value `42`
<span class="boring">}</span></code></pre></pre>
<p>Rust's ownership system is baked into the type system: each function has to declare in its signature
<em>how</em> it wants to interact with its arguments.</p>
<p>So far, all our methods and functions have <strong>consumed</strong> their arguments: they've taken ownership of them.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn description(self) -&gt; String {
        self.description
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Ticket::description</code> takes ownership of the <code>Ticket</code> instance it's called on.<br />
This is known as <strong>move semantics</strong>: ownership of the value (<code>self</code>) is <strong>moved</strong> from the caller to
the callee, and the caller can't use it anymore.</p>
<p>That's exactly the language used by the compiler in the error message we saw earlier:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`, 
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>In particular, this is the sequence of events that unfold when we call <code>ticket.status()</code>:</p>
<ul>
<li><code>Ticket::status</code> takes ownership of the <code>Ticket</code> instance</li>
<li><code>Ticket::status</code> extracts <code>status</code> from <code>self</code> and transfers ownership of <code>status</code> back to the caller</li>
<li>The rest of the <code>Ticket</code> instance is discarded (<code>title</code> and <code>description</code>)</li>
</ul>
<p>When we try to use <code>ticket</code> again via <code>ticket.title()</code>, the compiler complains: the <code>ticket</code> value is gone now,
we no longer own it, therefore we can't use it anymore.</p>
<p>To build <em>useful</em> accessor methods we need to start working with <strong>references</strong>.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>It is desirable to have methods that can read the value of a variable without taking ownership of it.<br />
Programming would be quite limited otherwise. In Rust, that's done via <strong>borrowing</strong>.</p>
<p>Whenever you borrow a value, you get a <strong>reference</strong> to it.<br />
References are tagged with their privileges<sup class="footnote-reference"><a href="#refine">1</a></sup>:</p>
<ul>
<li>Immutable references (<code>&amp;</code>) allow you to read the value, but not to mutate it</li>
<li>Mutable references (<code>&amp;mut</code>) allow you to read and mutate the value</li>
</ul>
<p>Going back to the goals of Rust's ownership system:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
</ul>
<p>To ensure these two properties, Rust has to introduce some restrictions on references:</p>
<ul>
<li>You can't have a mutable reference and an immutable reference to the same value at the same time</li>
<li>You can't have more than one mutable reference to the same value at the same time</li>
<li>The owner can't mutate the value while it's being borrowed</li>
<li>You can have as many immutable references as you want, as long as there are no mutable references</li>
</ul>
<p>In a way, you can think of an immutable reference as a "read-only" lock on the value,
while a mutable reference is like a "read-write" lock.</p>
<p>All these restrictions are enforced at compile-time by the borrow checker.</p>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<p>How do you borrow a value, in practice?<br />
By adding <code>&amp;</code> or <code>&amp;mut</code> <strong>in front a variable</strong>, you're borrowing its value.
Careful though! The same symbols (<code>&amp;</code> and <code>&amp;mut</code>) in <strong>front of a type</strong> have a different meaning:
they denote a different type, a reference to the original type.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">struct Configuration {
    version: u32,
    active: bool,
}

fn main() {
    let config = Configuration {
        version: 1,
        active: true,
    };
    // `b` is a reference to the `version` field of `config`.
    // The type of `b` is `&amp;u32`, since it contains a reference to a `u32` value.
    // We create a reference by borrowing `config.version`, using the `&amp;` operator.
    // Same symbol (`&amp;`), different meaning depending on the context!
    let b: &amp;u32 = &amp;config.version;
    //     ^ The type annotation is not necessary, 
    //       it's just there to clarify what's going on
}</code></pre></pre>
<p>The same concept applies to function arguments and return types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `f` takes a mutable reference to a `u32` as an argument, 
// bound to the name `number`
fn f(number: &amp;mut u32) -&gt; &amp;u32 {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="breathe-in-breathe-out"><a class="header" href="#breathe-in-breathe-out">Breathe in, breathe out</a></h2>
<p>Rust's ownership system can be a bit overwhelming at first.<br />
But don't worry: it'll become second nature with practice.<br />
And you're going to get a lot of practice over the rest of this chapter, as well as the rest of the course!
We'll revisit each concept multiple times to make sure you get familiar with them
and truly understand how they work.</p>
<p>Towards the end of this chapter we'll explain <em>why</em> Rust's ownership system is designed the way it is.
For the time being, focus on understanding the <em>how</em>. Take each compiler error as a learning opportunity!</p>
<div class="footnote-definition" id="refine"><sup class="footnote-definition-label">1</sup>
<p>This is a great mental model to start out, but it doesn't capture the <em>full</em> picture.
We'll refine our understanding of references <a href="03_ticket_v1/../07_threads/06_interior_mutability.html">later in the course</a>.</p>
</div>
<h2 id="exercise-19"><a class="header" href="#exercise-19">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership"><code>03_ticket_v1/06_ownership</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-references"><a class="header" href="#mutable-references">Mutable references</a></h1>
<p>Your accessor methods should look like this now:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }

    pub fn description(&amp;self) -&gt; &amp;String {
        &amp;self.description
    }

    pub fn status(&amp;self) -&gt; &amp;String {
        &amp;self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A sprinkle of <code>&amp;</code> here and there did the trick!<br />
We now have a way to access the fields of a <code>Ticket</code> instance without consuming it in the process.
Let's see how we can enhance our <code>Ticket</code> struct with <strong>setter methods</strong> next.</p>
<h2 id="setters"><a class="header" href="#setters">Setters</a></h2>
<p>Setter methods allow users to change the values of <code>Ticket</code>'s private fields while making sure that its invariants
are respected (i.e. you can't set a <code>Ticket</code>'s title to an empty string).</p>
<p>There are two common ways to implement setters in Rust:</p>
<ul>
<li>Taking <code>self</code> as input.</li>
<li>Taking <code>&amp;mut self</code> as input.</li>
</ul>
<h3 id="taking-self-as-input"><a class="header" href="#taking-self-as-input">Taking <code>self</code> as input</a></h3>
<p>The first approach looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(mut self, new_title: String) -&gt; Self {
        // Validate the new title [...]
        self.title = new_title;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It takes ownership of <code>self</code>, changes the title, and returns the modified <code>Ticket</code> instance.<br />
This is how you'd use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
let ticket = ticket.set_title("New title".into());
<span class="boring">}</span></code></pre></pre>
<p>Since <code>set_title</code> takes ownership of <code>self</code> (i.e. it <strong>consumes it</strong>), we need to reassign the result to a variable.
In the example above we take advantage of <strong>variable shadowing</strong> to reuse the same variable name: when
you declare a new variable with the same name as an existing one, the new variable <strong>shadows</strong> the old one. This
is a common pattern in Rust code.</p>
<p><code>self</code>-setters work quite nicely when you need to change multiple fields at once: you can chain multiple calls together!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = ticket
    .set_title("New title".into())
    .set_description("New description".into())
    .set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h3 id="taking-mut-self-as-input"><a class="header" href="#taking-mut-self-as-input">Taking <code>&amp;mut self</code> as input</a></h3>
<p>The second approach to setters, using <code>&amp;mut self</code>, looks like this instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(&amp;mut self, new_title: String) {
        // Validate the new title [...]
        
        self.title = new_title;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This time the method takes a mutable reference to <code>self</code> as input, changes the title, and that's it.
Nothing is returned.</p>
<p>You'd use it like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ticket = Ticket::new("Title".into(), "Description".into(), "To-Do".into());
ticket.set_title("New title".into());

// Use the modified ticket
<span class="boring">}</span></code></pre></pre>
<p>Ownership stays with the caller, so the original <code>ticket</code> variable is still valid. We don't need to reassign the result.
We need to mark <code>ticket</code> as mutable though, because we're taking a mutable reference to it.</p>
<p><code>&amp;mut</code>-setters have a downside: you can't chain multiple calls together.
Since they don't return the modified <code>Ticket</code> instance, you can't call another setter on the result of the first one.
You have to call each setter separately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ticket.set_title("New title".into());
ticket.set_description("New description".into());
ticket.set_status("In Progress".into());
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-20"><a class="header" href="#exercise-20">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/07_setters"><code>03_ticket_v1/07_setters</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-layout"><a class="header" href="#memory-layout">Memory layout</a></h1>
<p>We've looked at ownership and references from an operational point of view—what you can and can't do with them.
Now it's a good time to take a look under the hood: let's talk about <strong>memory</strong>.</p>
<h2 id="stack-and-heap"><a class="header" href="#stack-and-heap">Stack and heap</a></h2>
<p>When discussing memory, you'll often hear people talk about the <strong>stack</strong> and the <strong>heap</strong>.<br />
These are two different memory regions used by programs to store data.</p>
<p>Let's start with the stack.</p>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<p>The <strong>stack</strong> is a <strong>LIFO</strong> (Last In, First Out) data structure.<br />
When you call a function, a new <strong>stack frame</strong> is added on top of the stack. That stack frame stores
the function's arguments, local variables and a few "bookkeeping" values.<br />
When the function returns, the stack frame is popped off the stack<sup class="footnote-reference"><a href="#stack-overflow">1</a></sup>.</p>
<pre><code class="language-text">                                 +-----------------+
                       func2     | frame for func2 |   func2
+-----------------+  is called   +-----------------+  returns   +-----------------+
| frame for func1 | -----------&gt; | frame for func1 | ---------&gt; | frame for func1 |
+-----------------+              +-----------------+            +-----------------+
</code></pre>
<p>From an operational point of view, stack allocation/de-allocation is <strong>very fast</strong>.<br />
We are always pushing and popping data from the top of the stack, so we don't need to search for free memory.
We also don't have to worry about fragmentation: the stack is a single contiguous block of memory.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust will often allocate data on the stack.<br />
You have a <code>u32</code> input argument in a function? Those 32 bits will be on the stack.<br />
You define a local variable of type <code>i64</code>? Those 64 bits will be on the stack.<br />
It all works quite nicely because the size of those integers is known at compile time, therefore
the compiled program knows how much space it needs to reserve on the stack for them.</p>
<h3 id="stdmemsize_of"><a class="header" href="#stdmemsize_of"><code>std::mem::size_of</code></a></h3>
<p>You can verify how much space a type would take on the stack
using the <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html"><code>std::mem::size_of</code></a> function.</p>
<p>For a <code>u8</code>, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We'll explain this funny-looking syntax (`::&lt;u8&gt;`) later on.
// Ignore it for now.
assert_eq!(std::mem::size_of::&lt;u8&gt;(), 1);
<span class="boring">}</span></code></pre></pre>
<p>1 makes sense, because a <code>u8</code> is 8 bits long, or 1 byte.</p>
<div class="footnote-definition" id="stack-overflow"><sup class="footnote-definition-label">1</sup>
<p>If you have nested function calls, each function pushes its data onto the stack when it's called but
it doesn't pop it off until the innermost function returns.
If you have too many nested function calls, you can run out of stack space—the stack is not infinite!
That's called a <a href="https://en.wikipedia.org/wiki/Stack_overflow"><strong>stack overflow</strong></a>.</p>
</div>
<h2 id="exercise-21"><a class="header" href="#exercise-21">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack"><code>03_ticket_v1/08_stack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<p>The stack is great, but it can't solve all our problems. What about data whose size is not known at compile time?
Collections, strings, and other dynamically-sized data cannot be (entirely) stack-allocated.
That's where the <strong>heap</strong> comes in.</p>
<h2 id="heap-allocations"><a class="header" href="#heap-allocations">Heap allocations</a></h2>
<p>You can visualize the heap as a big chunk of memory—a huge array, if you will.<br />
Whenever you need to store data on the heap, you ask a special program, the <strong>allocator</strong>, to reserve for you
a subset of the heap. We call this interaction (and the memory you reserved) a <strong>heap allocation</strong>.
If the allocation succeeds, the allocator will give you a <strong>pointer</strong> to the start of the reserved block.</p>
<h2 id="no-automatic-de-allocation"><a class="header" href="#no-automatic-de-allocation">No automatic de-allocation</a></h2>
<p>The heap is structured quite differently from the stack.<br />
Heap allocations are not contiguous, they can be located anywhere inside the heap.</p>
<pre><code>+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
</code></pre>
<p>It's the allocator's job to keep track of which parts of the heap are in use and which are free.
The allocator won't automatically free the memory you allocated, though: you need to be deliberate about it,
calling the allocator again to <strong>free</strong> the memory you no longer need.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>The heap's flexibility comes at a cost: heap allocations are <strong>slower</strong> than stack allocations.
There's a lot more bookkeeping involved!<br />
If you read articles about performance optimization you'll often be advised to minimize heap allocations
and prefer stack-allocated data whenever possible.</p>
<h2 id="strings-memory-layout"><a class="header" href="#strings-memory-layout"><code>String</code>'s memory layout</a></h2>
<p>When you create a local variable of type <code>String</code>,
Rust is forced to allocate on the heap<sup class="footnote-reference"><a href="#empty">1</a></sup>: it doesn't know in advance how much text you're going to put in it,
so it can't reserve the right amount of space on the stack.<br />
But a <code>String</code> is not <em>entirely</em> heap-allocated, it also keeps some data on the stack. In particular:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the string, i.e. how many bytes are in the string.</li>
<li>The <strong>capacity</strong> of the string, i.e. how many bytes have been reserved on the heap.</li>
</ul>
<p>Let's look at an example to understand this better:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
<span class="boring">}</span></code></pre></pre>
<p>If you run this code, memory will be laid out like this:</p>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>We asked for a <code>String</code> that can hold up to 5 bytes of text.<br />
<code>String::with_capacity</code> goes to the allocator and asks for 5 bytes of heap memory. The allocator returns
a pointer to the start of that memory block.<br />
The <code>String</code> is empty, though. On the stack, we keep track of this information by distinguishing between
the length and the capacity: this <code>String</code> can hold up to 5 bytes, but it currently holds 0 bytes of
actual text.</p>
<p>If you push some text into the <code>String</code>, the situation will change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str("Hey");
<span class="boring">}</span></code></pre></pre>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p><code>s</code> now holds 3 bytes of text. Its length is updated to 3, but capacity remains 5.
Three of the five bytes on the heap are used to store the characters <code>H</code>, <code>e</code>, and <code>y</code>.</p>
<h3 id="usize"><a class="header" href="#usize"><code>usize</code></a></h3>
<p>How much space do we need to store pointer, length and capacity on the stack?<br />
It depends on the <strong>architecture</strong> of the machine you're running on.</p>
<p>Every memory location on your machine has an <a href="https://en.wikipedia.org/wiki/Memory_address"><strong>address</strong></a>, commonly
represented as an unsigned integer.
Depending on the maximum size of the address space (i.e. how much memory your machine can address),
this integer can have a different size. Most modern machines use either a 32-bit or a 64-bit address space.</p>
<p>Rust abstracts away these architecture-specific details by providing the <code>usize</code> type:
an unsigned integer that's as big as the number of bytes needed to address memory on your machine.
On a 32-bit machine, <code>usize</code> is equivalent to <code>u32</code>. On a 64-bit machine, it matches <code>u64</code>.</p>
<p>Capacity, length and pointers are all represented as <code>usize</code>s in Rust<sup class="footnote-reference"><a href="#equivalence">2</a></sup>.</p>
<h3 id="no-stdmemsize_of-for-the-heap"><a class="header" href="#no-stdmemsize_of-for-the-heap">No <code>std::mem::size_of</code> for the heap</a></h3>
<p><code>std::mem::size_of</code> returns the amount of space a type would take on the stack,
which is also known as the <strong>size of the type</strong>.</p>
<blockquote>
<p>What about the memory buffer that <code>String</code> is managing on the heap? Isn't that
part of the size of <code>String</code>?</p>
</blockquote>
<p>No!<br />
That heap allocation is a <strong>resource</strong> that <code>String</code> is managing.
It's not considered to be part of the <code>String</code> type by the compiler.</p>
<p><code>std::mem::size_of</code> doesn't know (or care) about additional heap-allocated data
that a type might manage or refer to via pointers, as is the case with <code>String</code>,
therefore it doesn't track its size.</p>
<p>Unfortunately there is no equivalent of <code>std::mem::size_of</code> to measure the amount of
heap memory that a certain value is allocating at runtime. Some types might
provide methods to inspect their heap usage (e.g. <code>String</code>'s <code>capacity</code> method),
but there is no general-purpose "API" to retrieve runtime heap usage in Rust.<br />
You can, however, use a memory profiler tool (e.g. <a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT</a>
or <a href="https://docs.rs/dhat/latest/dhat/">a custom allocator</a>) to inspect the heap usage of your program.</p>
<div class="footnote-definition" id="empty"><sup class="footnote-definition-label">1</sup>
<p><code>std</code> doesn't allocate if you create an <strong>empty</strong> <code>String</code> (i.e. <code>String::new()</code>).
Heap memory will be reserved when you push data into it for the first time.</p>
</div>
<div class="footnote-definition" id="equivalence"><sup class="footnote-definition-label">2</sup>
<p>The size of a pointer depends on the operating system too.
In certain environments, a pointer is <strong>larger</strong> than a memory address (e.g. <a href="https://blog.acolyer.org/2019/05/28/cheri-abi/">CHERI</a>).
Rust makes the simplifying assumption that pointers are the same size as memory addresses,
which is true for most modern systems you're likely to encounter.</p>
</div>
<h2 id="exercise-22"><a class="header" href="#exercise-22">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap"><code>03_ticket_v1/09_heap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>What about references, like <code>&amp;String</code> or <code>&amp;mut String</code>? How are they represented in memory?</p>
<p>Most references<sup class="footnote-reference"><a href="#fat">1</a></sup> in Rust are represented, in memory, as a pointer to a memory location.<br />
It follows that their size is the same as the size of a pointer, a <code>usize</code>.</p>
<p>You can verify this using <code>std::mem::size_of</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(std::mem::size_of::&lt;&amp;String&gt;(), 8);
assert_eq!(std::mem::size_of::&lt;&amp;mut String&gt;(), 8);
<span class="boring">}</span></code></pre></pre>
<p>A <code>&amp;String</code>, in particular, is a pointer to the memory location where the <code>String</code>'s metadata is stored.<br />
If you run this snippet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("Hey");
let r = &amp;s;
<span class="boring">}</span></code></pre></pre>
<p>you'll get something like this in memory:</p>
<pre><code>           --------------------------------------
           |                                    |
      +----v----+--------+----------+      +----|----+
Stack | pointer | length | capacity |      | pointer |
      |  |      |   3    |    5     |      |         |
      +--|  ----+--------+----------+      +---------+
         |          s                           r
         |
         v
       +---+---+---+---+---+
Heap   | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>It's a pointer to a pointer to the heap-allocated data, if you will.
The same goes for <code>&amp;mut String</code>.</p>
<h2 id="not-all-pointers-point-to-the-heap"><a class="header" href="#not-all-pointers-point-to-the-heap">Not all pointers point to the heap</a></h2>
<p>The example above should clarify one thing: not all pointers point to the heap.<br />
They just point to a memory location, which <em>may</em> be on the heap, but doesn't have to be.</p>
<div class="footnote-definition" id="fat"><sup class="footnote-definition-label">1</sup>
<p><a href="03_ticket_v1/../04_traits/06_str_slice.html">Later in the course</a> we'll talk about <strong>fat pointers</strong>,
i.e. pointers with additional metadata. As the name implies, they are larger than
the pointers we discussed in this chapter, also known as <strong>thin pointers</strong>.</p>
</div>
<h2 id="exercise-23"><a class="header" href="#exercise-23">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/10_references_in_memory"><code>03_ticket_v1/10_references_in_memory</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructors"><a class="header" href="#destructors">Destructors</a></h1>
<p>When introducing the heap, we mentioned that you're responsible for freeing the memory you allocate.<br />
When introducing the borrow-checker, we also stated that you rarely have to manage memory directly in Rust.</p>
<p>These two statements might seem contradictory at first.
Let's see how they fit together by introducing <strong>scopes</strong> and <strong>destructors</strong>.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>The <strong>scope</strong> of a variable is the region of Rust code where that variable is valid, or <strong>alive</strong>.</p>
<p>The scope of a variable starts with its declaration.
It ends when one of the following happens:</p>
<ol>
<li>the block (i.e. the code between <code>{}</code>) where the variable was declared ends
<pre><pre class="playground"><code class="language-rust">fn main() {
   // `x` is not yet in scope here
   let y = "Hello".to_string();
   let x = "World".to_string(); // &lt;-- x's scope starts here...
   let h = "!".to_string(); //   |
} //  &lt;-------------- ...and ends here</code></pre></pre>
</li>
<li>ownership of the variable is transferred to someone else (e.g. a function or another variable)
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
   // Do something [...]
}

fn main() {
    let s = "Hello".to_string(); // &lt;-- s's scope starts here...
                //                    | 
    compute(s); // &lt;------------------- ..and ends here
                //   because `s` is moved into `compute`
}</code></pre></pre>
</li>
</ol>
<h2 id="destructors-1"><a class="header" href="#destructors-1">Destructors</a></h2>
<p>When the owner of a value goes out of scope, Rust invokes its <strong>destructor</strong>.<br />
The destructor tries to clean up the resources used by that value—in particular, whatever memory it allocated.</p>
<p>You can manually invoke the destructor of a value by passing it to <code>std::mem::drop</code>.<br />
That's why you'll often hear Rust developers saying "that value has been <strong>dropped</strong>" as a way to state that a value
has gone out of scope and its destructor has been invoked.</p>
<h3 id="visualizing-drop-points"><a class="header" href="#visualizing-drop-points">Visualizing drop points</a></h3>
<p>We can insert explicit calls to <code>drop</code> to "spell out" what the compiler does for us. Going back to the previous example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
}</code></pre></pre>
<p>It's equivalent to:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
   // Variables are dropped in reverse order of declaration
   drop(h);
   drop(x);
   drop(y);
}</code></pre></pre>
<p>Let's look at the second example instead, where <code>s</code>'s ownership is transferred to <code>compute</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn compute(s: String) {
   // Do something [...]
}

fn main() {
   let s = "Hello".to_string();
   compute(s);
}</code></pre></pre>
<p>It's equivalent to this:</p>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
    // Do something [...]
    drop(t); // &lt;-- Assuming `t` wasn't dropped or moved 
             //     before this point, the compiler will call 
             //     `drop` here, when it goes out of scope
}

fn main() {
    let s = "Hello".to_string();
    compute(s);
}</code></pre></pre>
<p>Notice the difference: even though <code>s</code> is no longer valid after <code>compute</code> is called in <code>main</code>, there is no <code>drop(s)</code>
in <code>main</code>.
When you transfer ownership of a value to a function, you're also <strong>transferring the responsibility of cleaning it up</strong>.</p>
<p>This ensures that the destructor for a value is called <strong>at most<sup class="footnote-reference"><a href="#leak">1</a></sup> once</strong>, preventing
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">double free bugs</a> by design.</p>
<h3 id="use-after-drop"><a class="header" href="#use-after-drop">Use after drop</a></h3>
<p>What happens if you try to use a value after it's been dropped?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "Hello".to_string();
drop(x);
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>If you try to compile this code, you'll get an error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:4:20
  |
3 |     drop(x);
  |          - value moved here
4 |     println!("{}", x);
  |                    ^ value used here after move
<span class="boring">}</span></code></pre></pre>
<p>Drop <strong>consumes</strong> the value it's called on, meaning that the value is no longer valid after the call.<br />
The compiler will therefore prevent you from using it, avoiding <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">use-after-free bugs</a>.</p>
<h3 id="dropping-references"><a class="header" href="#dropping-references">Dropping references</a></h3>
<p>What if a variable contains a reference?<br />
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32;
let y = &amp;x;
drop(y);
<span class="boring">}</span></code></pre></pre>
<p>When you call <code>drop(y)</code>... nothing happens.<br />
If you actually try to compile this code, you'll get a warning:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference 
         instead of an owned value does nothing
 --&gt; src/main.rs:4:5
  |
4 |     drop(y);
  |     ^^^^^-^
  |          |
  |          argument has type `&amp;i32`
  |
</code></pre>
<p>It goes back to what we said earlier: we only want to call the destructor once.<br />
You can have multiple references to the same value—if we called the destructor for the value they point at
when one of them goes out of scope, what would happen to the others?
They would refer to a memory location that's no longer valid: a so-called <a href="https://en.wikipedia.org/wiki/Dangling_pointer"><strong>dangling pointer</strong></a>,
a close relative of <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><strong>use-after-free bugs</strong></a>.
Rust's ownership system rules out these kinds of bugs by design.</p>
<div class="footnote-definition" id="leak"><sup class="footnote-definition-label">1</sup>
<p>Rust doesn't guarantee that destructors will run. They won't, for example, if
you explicitly choose to <a href="03_ticket_v1/../07_threads/03_leak.html">leak memory</a>.</p>
</div>
<h2 id="exercise-24"><a class="header" href="#exercise-24">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor"><code>03_ticket_v1/11_destructor</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h1>
<p>We've covered a lot of foundational Rust concepts in this chapter.<br />
Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this time—just the exercise description and the tests to guide you.</p>
<h2 id="exercise-25"><a class="header" href="#exercise-25">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/12_outro"><code>03_ticket_v1/12_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>In the previous chapter we covered the basics of Rust's type and ownership system.<br />
It's time to dig deeper: we'll explore <strong>traits</strong>, Rust's take on interfaces.</p>
<p>Once you learn about traits, you'll start seeing their fingerprints all over the place.<br />
In fact, you've already seen traits in action throughout the previous chapter, e.g. <code>.into()</code> invocations as well
as operators like <code>==</code> and <code>+</code>.</p>
<p>On top of traits as a concept, we'll also cover some of the key traits that are defined in Rust's standard library:</p>
<ul>
<li>Operator traits (e.g. <code>Add</code>, <code>Sub</code>, <code>PartialEq</code>, etc.)</li>
<li><code>From</code> and <code>Into</code>, for infallible conversions</li>
<li><code>Clone</code> and <code>Copy</code>, for copying values</li>
<li><code>Deref</code> and deref coercion</li>
<li><code>Sized</code>, to mark types with a known size</li>
<li><code>Drop</code>, for custom cleanup logic</li>
</ul>
<p>Since we'll be talking about conversions, we'll seize the opportunity to plug some of the "knowledge gaps"
from the previous chapter—e.g. what is <code>"A title"</code>, exactly? Time to learn more about slices too!</p>
<h2 id="exercise-26"><a class="header" href="#exercise-26">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/00_intro"><code>04_traits/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-1"><a class="header" href="#traits-1">Traits</a></h1>
<p>Let's look again at our <code>Ticket</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>All our tests, so far, have been making assertions using <code>Ticket</code>'s fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(ticket.title(), "A new title");
<span class="boring">}</span></code></pre></pre>
<p>What if we wanted to compare two <code>Ticket</code> instances directly?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket1 = Ticket::new(/* ... */);
let ticket2 = Ticket::new(/* ... */);
ticket1 == ticket2
<span class="boring">}</span></code></pre></pre>
<p>The compiler will stop us:</p>
<pre><code class="language-text">error[E0369]: binary operation `==` cannot be applied to type `Ticket`
  --&gt; src/main.rs:18:13
   |
18 |     ticket1 == ticket2
   |     ------- ^^ ------- Ticket
   |     |
   |     Ticket
   |
note: an implementation of `PartialEq` might be missing for `Ticket`
</code></pre>
<p><code>Ticket</code> is a new type. Out of the box, there is <strong>no behavior attached to it</strong>.<br />
Rust doesn't magically infer how to compare two <code>Ticket</code> instances just because they contain <code>String</code>s.</p>
<p>The Rust compiler is nudging us in the right direction though: it's suggesting that we might be missing an implementation
of <code>PartialEq</code>. <code>PartialEq</code> is a <strong>trait</strong>!</p>
<h2 id="what-are-traits"><a class="header" href="#what-are-traits">What are traits?</a></h2>
<p>Traits are Rust's way of defining <strong>interfaces</strong>.<br />
A trait defines a set of methods that a type must implement to satisfy the trait's contract.</p>
<h3 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a trait</a></h3>
<p>The syntax for a trait definition goes like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait &lt;TraitName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>We might, for example, define a trait named <code>MaybeZero</code> that requires its implementors to define an <code>is_zero</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MaybeZero {
    fn is_zero(self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a trait</a></h3>
<p>To implement a trait for a type we use the <code>impl</code> keyword, just like we do for regular<sup class="footnote-reference"><a href="#inherent">1</a></sup> methods,
but the syntax is a bit different:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;TraitName&gt; for &lt;TypeName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
        // Method body
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, to implement the <code>MaybeZero</code> trait for a custom number type, <code>WrappingU32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WrappingU32 {
    inner: u32,
}

impl MaybeZero for WrappingU32 {
    fn is_zero(self) -&gt; bool {
        self.inner == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invoking-a-trait-method"><a class="header" href="#invoking-a-trait-method">Invoking a trait method</a></h3>
<p>To invoke a trait method, we use the <code>.</code> operator, just like we do with regular methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = WrappingU32 { inner: 5 };
assert!(!x.is_zero());
<span class="boring">}</span></code></pre></pre>
<p>To invoke a trait method, two things must be true:</p>
<ul>
<li>The type must implement the trait.</li>
<li>The trait must be in scope.</li>
</ul>
<p>To satisfy the latter, you may have to add a <code>use</code> statement for the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::MaybeZero;
<span class="boring">}</span></code></pre></pre>
<p>This is not necessary if:</p>
<ul>
<li>The trait is defined in the same module where the invocation occurs.</li>
<li>The trait is defined in the standard library's <strong>prelude</strong>.
The prelude is a set of traits and types that are automatically imported into every Rust program.
It's as if <code>use std::prelude::*;</code> was added at the beginning of every Rust module.</li>
</ul>
<p>You can find the list of traits and types in the prelude in the
<a href="https://doc.rust-lang.org/std/prelude/index.html">Rust documentation</a>.</p>
<div class="footnote-definition" id="inherent"><sup class="footnote-definition-label">1</sup>
<p>A method defined directly on a type, without using a trait, is also known as an <strong>inherent method</strong>.</p>
</div>
<h2 id="exercise-27"><a class="header" href="#exercise-27">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/01_trait"><code>04_traits/01_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-traits"><a class="header" href="#implementing-traits">Implementing traits</a></h1>
<p>When a type is defined in another crate (e.g. <code>u32</code>, from Rust's standard library), you
can't directly define new methods for it. If you try:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl u32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<pre><code class="language-text">error[E0390]: cannot define inherent `impl` for primitive types
  |
1 | impl u32 {
  | ^^^^^^^^
  |
  = help: consider using an extension trait instead
</code></pre>
<h2 id="extension-trait"><a class="header" href="#extension-trait">Extension trait</a></h2>
<p>An <strong>extension trait</strong> is a trait whose primary purpose is to attach new methods
to foreign types, such as <code>u32</code>.
That's exactly the pattern you deployed in the previous exercise, by defining
the <code>IsEven</code> trait and then implementing it for <code>i32</code> and <code>u32</code>. You are then
free to call <code>is_even</code> on those types as long as <code>IsEven</code> is in scope.</p>
<pre><pre class="playground"><code class="language-rust">// Bring the trait in scope
use my_library::IsEven;

fn main() {
    // Invoke its method on a type that implements it
    if 4.is_even() {
        // [...]
    }
}</code></pre></pre>
<h2 id="one-implementation"><a class="header" href="#one-implementation">One implementation</a></h2>
<p>There are limitations to the trait implementations you can write.<br />
The simplest and most straight-forward one: you can't implement the same trait twice,
in a crate, for the same type.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        true
    }
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject it:</p>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `IsEven` for type `u32`
   |
5  | impl IsEven for u32 {
   | ------------------- first implementation here
...
11 | impl IsEven for u32 {
   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`
</code></pre>
<p>There can be no ambiguity as to what trait implementation should be used when <code>IsEven::is_even</code>
is invoked on a <code>u32</code> value, therefore there can only be one.</p>
<h2 id="orphan-rule"><a class="header" href="#orphan-rule">Orphan rule</a></h2>
<p>Things get more nuanced when multiple crates are involved.
In particular, at least one of the following must be true:</p>
<ul>
<li>The trait is defined in the current crate</li>
<li>The implementor type is defined in the current crate</li>
</ul>
<p>This is known as Rust's <strong>orphan rule</strong>. Its goal is to make the method resolution
process unambiguous.</p>
<p>Imagine the following situation:</p>
<ul>
<li>Crate <code>A</code> defines the <code>IsEven</code> trait</li>
<li>Crate <code>B</code> implements <code>IsEven</code> for <code>u32</code></li>
<li>Crate <code>C</code> provides a (different) implementation of the <code>IsEven</code> trait for <code>u32</code></li>
<li>Crate <code>D</code> depends on both <code>B</code> and <code>C</code> and calls <code>1.is_even()</code></li>
</ul>
<p>Which implementation should be used? The one defined in <code>B</code>? Or the one defined in <code>C</code>?<br />
There's no good answer, therefore the orphan rule was defined to prevent this scenario.
Thanks to the orphan rule, neither crate <code>B</code> nor crate <code>C</code> would compile.</p>
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further reading</a></h2>
<ul>
<li>There are some caveats and exceptions to the orphan rule as stated above.
Check out <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">the reference</a>
if you want to get familiar with its nuances.</li>
</ul>
<h2 id="exercise-28"><a class="header" href="#exercise-28">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/02_orphan_rule"><code>04_traits/02_orphan_rule</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator overloading</a></h1>
<p>Now that we have a basic understanding of what traits are, let's circle back to <strong>operator overloading</strong>.
Operator overloading is the ability to define custom behavior for operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, etc.</p>
<h2 id="operators-are-traits"><a class="header" href="#operators-are-traits">Operators are traits</a></h2>
<p>In Rust, operators are traits.<br />
For each operator, there is a corresponding trait that defines the behavior of that operator.
By implementing that trait for your type, you <strong>unlock</strong> the usage of the corresponding operators.</p>
<p>For example, the <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code> trait</a> defines the behavior of
the <code>==</code> and <code>!=</code> operators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `PartialEq` trait definition, from Rust's standard library
// (It is *slightly* simplified, for now)
pub trait PartialEq {
    // Required method
    //
    // `Self` is a Rust keyword that stands for 
    // "the type that is implementing the trait"
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    // Provided method
    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>When you write <code>x == y</code> the compiler will look for an implementation of the <code>PartialEq</code> trait for the types of <code>x</code> and <code>y</code>
and replace <code>x == y</code> with <code>x.eq(y)</code>. It's syntactic sugar!</p>
<p>This is the correspondence for the main operators:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>-</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>*</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>/</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>%</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
<tr><td><code>==</code> and <code>!=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td></tr>
</tbody></table>
</div>
<p>Arithmetic operators live in the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module,
while comparison ones live in the <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module.</p>
<h2 id="default-implementations"><a class="header" href="#default-implementations">Default implementations</a></h2>
<p>The comment on <code>PartialEq::ne</code> states that "<code>ne</code> is a provided method".<br />
It means that <code>PartialEq</code> provides a <strong>default implementation</strong> for <code>ne</code> in the trait definition—the <code>{ ... }</code> elided
block in the definition snippet.<br />
If we expand the elided block, it looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's what you expect: <code>ne</code> is the negation of <code>eq</code>.<br />
Since a default implementation is provided, you can skip implementing <code>ne</code> when you implement <code>PartialEq</code> for your type.
It's enough to implement <code>eq</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WrappingU8 {
    inner: u8,
}

impl PartialEq for WrappingU8 {
    fn eq(&amp;self, other: &amp;WrappingU8) -&gt; bool {
        self.inner == other.inner
    }
    
    // No `ne` implementation here
}
<span class="boring">}</span></code></pre></pre>
<p>You are not forced to use the default implementation though.
You can choose to override it when you implement the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType;

impl PartialEq for MyType {
    fn eq(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
    }

    fn ne(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-29"><a class="header" href="#exercise-29">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading"><code>04_traits/03_operator_overloading</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macros"><a class="header" href="#derive-macros">Derive macros</a></h1>
<p>Implementing <code>PartialEq</code> for <code>Ticket</code> was a bit tedious, wasn't it?
You had to manually compare each field of the struct.</p>
<h2 id="destructuring-syntax"><a class="header" href="#destructuring-syntax">Destructuring syntax</a></h2>
<p>Furthermore, the implementation is brittle: if the struct definition changes
(e.g. a new field is added), you have to remember to update the <code>PartialEq</code> implementation.</p>
<p>You can mitigate the risk by <strong>destructuring</strong> the struct into its fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the definition of <code>Ticket</code> changes, the compiler will error out, complaining that your
destructuring is no longer exhaustive.<br />
You can also rename struct fields, to avoid variable shadowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        let Ticket {
            title: other_title,
            description: other_description,
            status: other_status,
        } = other;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Destructuring is a useful pattern to have in your toolkit, but
there's an even more convenient way to do this: <strong>derive macros</strong>.</p>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>You've already encountered a few macros in past exercises:</p>
<ul>
<li><code>assert_eq!</code> and <code>assert!</code>, in the test cases</li>
<li><code>println!</code>, to print to the console</li>
</ul>
<p>Rust macros are <strong>code generators</strong>.<br />
They generate new Rust code based on the input you provide, and that generated code is then compiled alongside
the rest of your program. Some macros are built into Rust's standard library, but you can also
write your own. We won't be creating our macro in this course, but you can find some useful
pointers in the <a href="04_traits/04_derive.html#further-reading">"Further reading" section</a>.</p>
<h3 id="inspection"><a class="header" href="#inspection">Inspection</a></h3>
<p>Some IDEs let you expand a macro to inspect the generated code. If that's not possible, you can use
<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>.</p>
<h3 id="derive-macros-1"><a class="header" href="#derive-macros-1">Derive macros</a></h3>
<p>A <strong>derive macro</strong> is a particular flavour of Rust macro. It is specified as an <strong>attribute</strong> on top of a struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Ticket {
    title: String,
    description: String,
    status: String
}
<span class="boring">}</span></code></pre></pre>
<p>Derive macros are used to automate the implementation of common (and "obvious") traits for custom types.
In the example above, the <code>PartialEq</code> trait is automatically implemented for <code>Ticket</code>.
If you expand the macro, you'll see that the generated code is functionally equivalent to the one you wrote manually,
although a bit more cumbersome to read:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[automatically_derived]
impl ::core::cmp::PartialEq for Ticket {
    #[inline]
    fn eq(&amp;self, other: &amp;Ticket) -&gt; bool {
        self.title == other.title &amp;&amp; self.description == other.description
            &amp;&amp; self.status == other.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will nudge you to derive traits when possible.</p>
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further reading</a></h2>
<ul>
<li><a href="https://veykril.github.io/tlborm/">The little book of Rust macros</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">Proc macro workshop</a></li>
</ul>
<h2 id="exercise-30"><a class="header" href="#exercise-30">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive"><code>04_traits/04_derive</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-bounds"><a class="header" href="#trait-bounds">Trait bounds</a></h1>
<p>We've seen two use cases for traits so far:</p>
<ul>
<li>Unlocking "built-in" behaviour (e.g. operator overloading)</li>
<li>Adding new behaviour to existing types (i.e. extension traits)</li>
</ul>
<p>There's a third use case: <strong>generic programming</strong>.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>All our functions and methods, so far, have been working with <strong>concrete types</strong>.<br />
Code that operates on concrete types is usually straightforward to write and understand. But it's also
limited in its reusability.<br />
Let's imagine, for example, that we want to write a function that returns <code>true</code> if an integer is even.
Working with concrete types, we'd have to write a separate function for each integer type we want to
support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_even_i32(n: i32) -&gt; bool {
    n % 2 == 0
}

fn is_even_i64(n: i64) -&gt; bool {
    n % 2 == 0
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, we could write a single extension trait and then different implementations for each integer type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for i32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

impl IsEven for i64 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

// Etc.
<span class="boring">}</span></code></pre></pre>
<p>The duplication remains.</p>
<h2 id="generic-programming"><a class="header" href="#generic-programming">Generic programming</a></h2>
<p>We can do better using <strong>generics</strong>.<br />
Generics allow us to write code that works with a <strong>type parameter</strong> instead of a concrete type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T) 
where
    T: IsEven + Debug
{
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_if_even</code> is a <strong>generic function</strong>.<br />
It isn't tied to a specific input type. Instead, it works with any type <code>T</code> that:</p>
<ul>
<li>Implements the <code>IsEven</code> trait.</li>
<li>Implements the <code>Debug</code> trait.</li>
</ul>
<p>This contract is expressed with a <strong>trait bound</strong>: <code>T: IsEven + Debug</code>.<br />
The <code>+</code> symbol is used to require that <code>T</code> implements multiple traits. <code>T: IsEven + Debug</code> is equivalent to
"where <code>T</code> implements <code>IsEven</code> <strong>and</strong> <code>Debug</code>".</p>
<h2 id="trait-bounds-1"><a class="header" href="#trait-bounds-1">Trait bounds</a></h2>
<p>What purpose do trait bounds serve in <code>print_if_even</code>?<br />
To find out, let's try to remove them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T) {
    if n.is_even() {
        println!("{n:?} is even");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code won't compile:</p>
<pre><code class="language-text">error[E0599]: no method named `is_even` found for type parameter `T` in the current scope
 --&gt; src/lib.rs:2:10
  |
1 | fn print_if_even&lt;T&gt;(n: T) {
  |                  - method `is_even` not found for this type parameter
2 |     if n.is_even() {
  |          ^^^^^^^ method not found in `T`

error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/lib.rs:3:19
  |
3 |         println!("{n:?} is even");
  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
  |
help: consider restricting type parameter `T`
  |
1 | fn print_if_even&lt;T: std::fmt::Debug&gt;(n: T) {
  |                   +++++++++++++++++
</code></pre>
<p>Without trait bounds, the compiler doesn't know what <code>T</code> <strong>can do</strong>.<br />
It doesn't know that <code>T</code> has an <code>is_even</code> method, and it doesn't know how to format <code>T</code> for printing.
From the compiler point of view, a bare <code>T</code> has no behaviour at all.<br />
Trait bounds restrict the set of types that can be used by ensuring that the behaviour required by the function
body is present.</p>
<h2 id="syntax-inlining-trait-bounds"><a class="header" href="#syntax-inlining-trait-bounds">Syntax: inlining trait bounds</a></h2>
<p>All the examples above used a <strong><code>where</code> clause</strong> to specify trait bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T&gt;(n: T) 
where
    T: IsEven + Debug
//  ^^^^^^^^^^^^^^^^^
//  This is a `where` clause
{
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait bounds are simple, you can <strong>inline</strong> them directly next to the type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;T: IsEven + Debug&gt;(n: T) {
    //           ^^^^^^^^^^^^^^^^^
    //           This is an inline trait bound
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="syntax-meaningful-names"><a class="header" href="#syntax-meaningful-names">Syntax: meaningful names</a></h2>
<p>In the examples above, we used <code>T</code> as the type parameter name. This is a common convention when a function has
only one type parameter.<br />
Nothing stops you from using a more meaningful name, though:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_if_even&lt;Number: IsEven + Debug&gt;(n: Number) {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It is actually <strong>desirable</strong> to use meaningful names when there are multiple type parameters at play or when the name
<code>T</code> doesn't convey enough information about the type's role in the function.
Maximize clarity and readability when naming type parameters, just as you would with variables or function parameters.
Follow Rust's conventions though: use camel case for type parameter names.</p>
<h2 id="the-function-signature-is-king"><a class="header" href="#the-function-signature-is-king">The function signature is king</a></h2>
<p>You may wonder why we need trait bounds at all. Can't the compiler infer the required traits from the function's body?<br />
It could, but it won't.<br />
The rationale is the same as for <a href="04_traits/../02_basic_calculator/02_variables.html#function-arguments-are-variables">explicit type annotations on function parameters</a>:
each function signature is a contract between the caller and the callee, and the terms must be explicitly stated.
This allows for better error messages, better documentation, less unintentional breakages across versions,
and faster compilation times.</p>
<h2 id="exercise-31"><a class="header" href="#exercise-31">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/05_trait_bounds"><code>04_traits/05_trait_bounds</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-slices"><a class="header" href="#string-slices">String slices</a></h1>
<p>Throughout the previous chapters you've seen quite a few <strong>string literals</strong> being used in the code,
like <code>"To-Do"</code> or <code>"A ticket description"</code>.
They were always followed by a call to <code>.to_string()</code> or <code>.into()</code>. It's time to understand why!</p>
<h2 id="string-literals"><a class="header" href="#string-literals">String literals</a></h2>
<p>You define a string literal by enclosing the raw text in double quotes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> is <code>&amp;str</code>, a <strong>reference to a string slice</strong>.</p>
<h2 id="memory-layout-1"><a class="header" href="#memory-layout-1">Memory layout</a></h2>
<p><code>&amp;str</code> and <code>String</code> are different types—they're not interchangeable.<br />
Let's recall the memory layout of a <code>String</code> from our
<a href="04_traits/../03_ticket_v1/09_heap.html">previous exploration</a>.
If we run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
<span class="boring">}</span></code></pre></pre>
<p>we'll get this scenario in memory:</p>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>If you remember, we've <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">also examined</a>
how a <code>&amp;String</code> is laid out in memory:</p>
<pre><code class="language-text">     --------------------------------------
     |                                    |         
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &amp;s 
     |       
     v       
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
</code></pre>
<p><code>&amp;String</code> points to the memory location where the <code>String</code>'s metadata is stored.<br />
If we follow the pointer, we get to the heap-allocated data. In particular, we get to the first byte of the string, <code>H</code>.</p>
<p>What if we wanted a type that represents a <strong>substring</strong> of <code>s</code>? E.g. <code>ello</code> in <code>Hello</code>?</p>
<h2 id="string-slices-1"><a class="header" href="#string-slices-1">String slices</a></h2>
<p>A <code>&amp;str</code> is a <strong>view</strong> into a string, a <strong>reference</strong> to a sequence of UTF-8 bytes stored elsewhere.
You can, for example, create a <code>&amp;str</code> from a <code>String</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, it'd look like this:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p><code>slice</code> stores two pieces of information on the stack:</p>
<ul>
<li>A pointer to the first byte of the slice.</li>
<li>The length of the slice.</li>
</ul>
<p><code>slice</code> doesn't own the data, it just points to it: it's a <strong>reference</strong> to the <code>String</code>'s heap-allocated data.<br />
When <code>slice</code> is dropped, the heap-allocated data won't be deallocated, because it's still owned by <code>s</code>.
That's why <code>slice</code> doesn't have a <code>capacity</code> field: it doesn't own the data, so it doesn't need to know how much
space it was allocated for it; it only cares about the data it references.</p>
<h2 id="str-vs-string"><a class="header" href="#str-vs-string"><code>&amp;str</code> vs <code>&amp;String</code></a></h2>
<p>As a rule of thumb, use <code>&amp;str</code> rather than <code>&amp;String</code> whenever you need a reference to textual data.<br />
<code>&amp;str</code> is more flexible and generally considered more idiomatic in Rust code.</p>
<p>If a method returns a <code>&amp;String</code>, you're promising that there is heap-allocated UTF-8 text somewhere that
<strong>matches exactly</strong> the one you're returning a reference to.<br />
If a method returns a <code>&amp;str</code>, instead, you have a lot more freedom: you're just saying that <em>somewhere</em> there's a
bunch of text data and that a subset of it matches what you need, therefore you're returning a reference to it.</p>
<h2 id="exercise-32"><a class="header" href="#exercise-32">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice"><code>04_traits/06_str_slice</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-trait"><a class="header" href="#deref-trait"><code>Deref</code> trait</a></h1>
<p>In the previous exercise you didn't have to do much, did you?</p>
<p>Changing</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;str {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>was all you needed to do to get the code to compile and the tests to pass.
Some alarm bells should be ringing in your head though.</p>
<h2 id="it-shouldnt-work-but-it-does"><a class="header" href="#it-shouldnt-work-but-it-does">It shouldn't work, but it does</a></h2>
<p>Let's review the facts:</p>
<ul>
<li><code>self.title</code> is a <code>String</code></li>
<li><code>&amp;self.title</code> is, therefore, a <code>&amp;String</code></li>
<li>The output of the (modified) <code>title</code> method is <code>&amp;str</code></li>
</ul>
<p>You would expect a compiler error, wouldn't you? <code>Expected &amp;String, found &amp;str</code> or something similar.
Instead, it just works. <strong>Why</strong>?</p>
<h2 id="deref-to-the-rescue"><a class="header" href="#deref-to-the-rescue"><code>Deref</code> to the rescue</a></h2>
<p>The <code>Deref</code> trait is the mechanism behind the language feature known as <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion"><strong>deref coercion</strong></a>.<br />
The trait is defined in the standard library, in the <code>std::ops</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've slightly simplified the definition for now.
// We'll see the full definition later on.
pub trait Deref {
    type Target;
    
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><code>type Target</code> is an <strong>associated type</strong>.<br />
It's a placeholder for a concrete type that must be specified when the trait is implemented.</p>
<h2 id="deref-coercion"><a class="header" href="#deref-coercion">Deref coercion</a></h2>
<p>By implementing <code>Deref&lt;Target = U&gt;</code> for a type <code>T</code> you're telling the compiler that <code>&amp;T</code> and <code>&amp;U</code> are
somewhat interchangeable.<br />
In particular, you get the following behavior:</p>
<ul>
<li>References to <code>T</code> are implicitly converted into references to <code>U</code> (i.e. <code>&amp;T</code> becomes <code>&amp;U</code>)</li>
<li>You can call on <code>&amp;T</code> all the methods defined on <code>U</code> that take <code>&amp;self</code> as input.</li>
</ul>
<p>There is one more thing around the dereference operator, <code>*</code>, but we don't need it yet (see <code>std</code>'s docs
if you're curious).</p>
<h2 id="string-implements-deref"><a class="header" href="#string-implements-deref"><code>String</code> implements <code>Deref</code></a></h2>
<p><code>String</code> implements <code>Deref</code> with <code>Target = str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for String {
    type Target = str;
    
    fn deref(&amp;self) -&gt; &amp;str {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Thanks to this implementation and deref coercion, a <code>&amp;String</code> is automatically converted into a <code>&amp;str</code> when needed.</p>
<h2 id="dont-abuse-deref-coercion"><a class="header" href="#dont-abuse-deref-coercion">Don't abuse deref coercion</a></h2>
<p>Deref coercion is a powerful feature, but it can lead to confusion.<br />
Automatically converting types can make the code harder to read and understand. If a method with the same name
is defined on both <code>T</code> and <code>U</code>, which one will be called?</p>
<p>We'll examine later in the course the "safest" use cases for deref coercion: smart pointers.</p>
<h2 id="exercise-33"><a class="header" href="#exercise-33">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref"><code>04_traits/07_deref</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sized"><a class="header" href="#sized"><code>Sized</code></a></h1>
<p>There's more to <code>&amp;str</code> than meets the eye, even after having
investigated deref coercion.<br />
From our previous <a href="04_traits/../03_ticket_v1/10_references_in_memory.html">discussion on memory layouts</a>,
it would have been reasonable to expect <code>&amp;str</code> to be represented as a single <code>usize</code> on
the stack, a pointer. That's not the case though. <code>&amp;str</code> stores some <strong>metadata</strong> next
to the pointer: the length of the slice it points to. Going back to the example from
<a href="04_traits/06_str_slice.html">a previous section</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, skipping the first byte.
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>In memory, we get:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p>What's going on?</p>
<h2 id="dynamically-sized-types"><a class="header" href="#dynamically-sized-types">Dynamically sized types</a></h2>
<p><code>str</code> is a <strong>dynamically sized type</strong> (DST).<br />
A DST is a type whose size is not known at compile time. Whenever you have a
reference to a DST, like <code>&amp;str</code>, it has to include additional
information about the data it points to. It is a <strong>fat pointer</strong>.<br />
In the case of <code>&amp;str</code>, it stores the length of the slice it points to.
We'll see more examples of DSTs in the rest of the course.</p>
<h2 id="the-sized-trait"><a class="header" href="#the-sized-trait">The <code>Sized</code> trait</a></h2>
<p>Rust's <code>std</code> library defines a trait called <code>Sized</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sized {
    // This is an empty trait, no methods to implement.
}
<span class="boring">}</span></code></pre></pre>
<p>A type is <code>Sized</code> if its size is known at compile time. In other words, it's not a DST.</p>
<h3 id="marker-traits"><a class="header" href="#marker-traits">Marker traits</a></h3>
<p><code>Sized</code> is your first example of a <strong>marker trait</strong>.<br />
A marker trait is a trait that doesn't require any methods to be implemented. It doesn't define any behavior.
It only serves to <strong>mark</strong> a type as having certain properties.
The mark is then leveraged by the compiler to enable certain behaviors or optimizations.</p>
<h3 id="auto-traits"><a class="header" href="#auto-traits">Auto traits</a></h3>
<p>In particular, <code>Sized</code> is also an <strong>auto trait</strong>.<br />
You don't need to implement it explicitly; the compiler implements it automatically for you
based on the type's definition.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>All the types we've seen so far are <code>Sized</code>: <code>u32</code>, <code>String</code>, <code>bool</code>, etc.</p>
<p><code>str</code>, as we just saw, is not <code>Sized</code>.<br />
<code>&amp;str</code> is <code>Sized</code> though! We know its size at compile time: two <code>usize</code>s, one for the pointer
and one for the length.</p>
<h2 id="exercise-34"><a class="header" href="#exercise-34">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized"><code>04_traits/08_sized</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>Let's go back to where our string journey started:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("A title".into(), "A description".into(), "To-Do".into());
<span class="boring">}</span></code></pre></pre>
<p>We now know enough to start unpacking what <code>.into()</code> is doing here.</p>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The problem</a></h2>
<p>This is the signature of the <code>new</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We've also seen that string literals (such as <code>"A title"</code>) are of type <code>&amp;str</code>.<br />
We have a type mismatch here: a <code>String</code> is expected, but we have a <code>&amp;str</code>.
No magical coercion will come to save us this time; we need <strong>to perform a conversion</strong>.</p>
<h2 id="from-and-into-1"><a class="header" href="#from-and-into-1"><code>From</code> and <code>Into</code></a></h2>
<p>The Rust standard library defines two traits for <strong>infallible conversions</strong>: <code>From</code> and <code>Into</code>,
in the <code>std::convert</code> module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt;: Sized {
    fn from(value: T) -&gt; Self;
}

pub trait Into&lt;T&gt;: Sized {
    fn into(self) -&gt; T;
}
<span class="boring">}</span></code></pre></pre>
<p>These trait definitions showcase a few concepts that we haven't seen before: <strong>supertraits</strong> and <strong>implicit trait bounds</strong>.
Let's unpack those first.</p>
<h3 id="supertrait--subtrait"><a class="header" href="#supertrait--subtrait">Supertrait / Subtrait</a></h3>
<p>The <code>From: Sized</code> syntax implies that <code>From</code> is a <strong>subtrait</strong> of <code>Sized</code>: any type that
implements <code>From</code> must also implement <code>Sized</code>.
Alternatively, you could say that <code>Sized</code> is a <strong>supertrait</strong> of <code>From</code>.</p>
<h3 id="implicit-trait-bounds"><a class="header" href="#implicit-trait-bounds">Implicit trait bounds</a></h3>
<p>Every time you have a generic type parameter, the compiler implicitly assumes that it's <code>Sized</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T&gt; {
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>is actually equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: Sized&gt; 
{
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>In the case of <code>From&lt;T&gt;</code>, the trait definition is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T: Sized&gt;: Sized {
    fn from(value: T) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>In other words, <em>both</em> <code>T</code> and the type implementing <code>From&lt;T&gt;</code> must be <code>Sized</code>, even
though the former bound is implicit.</p>
<h3 id="negative-trait-bounds"><a class="header" href="#negative-trait-bounds">Negative trait bounds</a></h3>
<p>You can opt out of the implicit <code>Sized</code> bound with a <strong>negative trait bound</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T: ?Sized&gt; {
    //            ^^^^^^^
    //            This is a negative trait bound
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>This syntax reads as "<code>T</code> may or may not be <code>Sized</code>", and it allows you to
bind <code>T</code> to a DST (e.g. <code>Foo&lt;str&gt;</code>). It is a special case, though: negative trait bounds are exclusive to <code>Sized</code>,
you can't use them with other traits.</p>
<h2 id="str-to-string"><a class="header" href="#str-to-string"><code>&amp;str</code> to <code>String</code></a></h2>
<p>In <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors"><code>std</code>'s documentation</a>
you can see which <code>std</code> types implement the <code>From</code> trait.<br />
You'll find that <code>String</code> implements <code>From&lt;&amp;str&gt; for String</code>. Thus, we can write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let title = String::from("A title");
<span class="boring">}</span></code></pre></pre>
<p>We've been primarily using <code>.into()</code>, though.<br />
If you check out the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html#implementors">implementors of <code>Into</code></a>
you won't find <code>Into&lt;&amp;str&gt; for String</code>. What's going on?</p>
<p><code>From</code> and <code>Into</code> are <strong>dual traits</strong>.<br />
In particular, <code>Into</code> is implemented for any type that implements <code>From</code> using a <strong>blanket implementation</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If a type <code>U</code> implements <code>From&lt;T&gt;</code>, then <code>Into&lt;U&gt; for T</code> is automatically implemented. That's why
we can write <code>let title = "A title".into();</code>.</p>
<h2 id="into"><a class="header" href="#into"><code>.into()</code></a></h2>
<p>Every time you see <code>.into()</code>, you're witnessing a conversion between types.<br />
What's the target type, though?</p>
<p>In most cases, the target type is either:</p>
<ul>
<li>Specified by the signature of a function/method (e.g. <code>Ticket::new</code> in our example above)</li>
<li>Specified in the variable declaration with a type annotation (e.g. <code>let title: String = "A title".into();</code>)</li>
</ul>
<p><code>.into()</code> will work out of the box as long as the compiler can infer the target type from the context without ambiguity.</p>
<h2 id="exercise-35"><a class="header" href="#exercise-35">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/09_from"><code>04_traits/09_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-associated-types"><a class="header" href="#generics-and-associated-types">Generics and associated types</a></h1>
<p>Let's re-examine the definition for two of the traits we studied so far, <code>From</code> and <code>Deref</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self;
}

pub trait Deref {
    type Target;
    
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p>They both feature type parameters.<br />
In the case of <code>From</code>, it's a generic parameter, <code>T</code>.<br />
In the case of <code>Deref</code>, it's an associated type, <code>Target</code>.</p>
<p>What's the difference? Why use one over the other?</p>
<h2 id="at-most-one-implementation"><a class="header" href="#at-most-one-implementation">At most one implementation</a></h2>
<p>Due to how deref coercion works, there can only be one "target" type for a given type. E.g. <code>String</code> can
only deref to <code>str</code>.
It's about avoiding ambiguity: if you could implement <code>Deref</code> multiple times for a type,
which <code>Target</code> type should the compiler choose when you call a <code>&amp;self</code> method?</p>
<p>That's why <code>Deref</code> uses an associated type, <code>Target</code>.<br />
An associated type is uniquely determined <strong>by the trait implementation</strong>.
Since you can't implement <code>Deref</code> more than once, you'll only be able to specify one <code>Target</code> for a given type
and there won't be any ambiguity.</p>
<h2 id="generic-traits"><a class="header" href="#generic-traits">Generic traits</a></h2>
<p>On the other hand, you can implement <code>From</code> multiple times for a type, <strong>as long as the input type <code>T</code> is different</strong>.
For example, you can implement <code>From</code> for <code>WrappingU32</code> using both <code>u32</code> and <code>u16</code> as input types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u32&gt; for WrappingU32 {
    fn from(value: u32) -&gt; Self {
        WrappingU32 { inner: value }
    }
}

impl From&lt;u16&gt; for WrappingU32 {
    fn from(value: u16) -&gt; Self {
        WrappingU32 { inner: value.into() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>From&lt;u16&gt;</code> and <code>From&lt;u32&gt;</code> are considered <strong>different traits</strong>.<br />
There is no ambiguity: the compiler can determine which implementation to use based on type of the value being converted.</p>
<h2 id="case-study-add"><a class="header" href="#case-study-add">Case study: <code>Add</code></a></h2>
<p>As a closing example, consider the <code>Add</code> trait from the standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;RHS = Self&gt; {
    type Output;
    
    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It uses both mechanisms:</p>
<ul>
<li>it has a generic parameter, <code>RHS</code> (right-hand side), which defaults to <code>Self</code></li>
<li>it has an associated type, <code>Output</code>, the type of the result of the addition</li>
</ul>
<h3 id="rhs"><a class="header" href="#rhs"><code>RHS</code></a></h3>
<p><code>RHS</code> is a generic parameter to allow for different types to be added together.<br />
For example, you'll find these two implementations in the standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;u32&gt; for u32 {
    type Output = u32;
    
    fn add(self, rhs: u32) -&gt; u32 {
      //                      ^^^
      // This could be written as `Self::Output` instead.
      // The compiler doesn't care, as long as the type you
      // specify here matches the type you assigned to `Output` 
      // right above.
      // [...]
    }
}

impl Add&lt;&amp;u32&gt; for u32 {
    type Output = u32;
    
    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This allows the following code to compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5u32 + &amp;5u32 + 6u32;
<span class="boring">}</span></code></pre></pre>
<p>because <code>u32</code> implements <code>Add&lt;&amp;u32&gt;</code> <em>as well as</em> <code>Add&lt;u32&gt;</code>.</p>
<h3 id="output"><a class="header" href="#output"><code>Output</code></a></h3>
<p><code>Output</code> represents the type of the result of the addition.</p>
<p>Why do we need <code>Output</code> in the first place? Can't we just use <code>Self</code> as output, the type implementing <code>Add</code>?
We could, but it would limit the flexibility of the trait. In the standard library, for example, you'll find
this implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Add&lt;&amp;u32&gt; for &amp;u32 {
    type Output = u32;

    fn add(self, rhs: &amp;u32) -&gt; u32 {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The type they're implementing the trait for is <code>&amp;u32</code>, but the result of the addition is <code>u32</code>.<br />
It would be impossible<sup class="footnote-reference"><a href="#flexible">1</a></sup> to provide this implementation if <code>add</code> had to return <code>Self</code>, i.e. <code>&amp;u32</code> in this case.
<code>Output</code> lets <code>std</code> decouple the implementor from the return type, thus supporting this case.</p>
<p>On the other hand, <code>Output</code> can't be a generic parameter. The output type of the operation <strong>must</strong> be uniquely determined
once the types of the operands are known. That's why it's an associated type: for a given combination of implementor
and generic parameters, there is only one <code>Output</code> type.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>To recap:</p>
<ul>
<li>Use an <strong>associated type</strong> when the type must be uniquely determined for a given trait implementation.</li>
<li>Use a <strong>generic parameter</strong> when you want to allow multiple implementations of the trait for the same type,
with different input types.</li>
</ul>
<div class="footnote-definition" id="flexible"><sup class="footnote-definition-label">1</sup>
<p>Flexibility is rarely free: the trait definition is more complex due to <code>Output</code>, and implementors have to reason about
what they want to return. The trade-off is only justified if that flexibility is actually needed. Keep that in mind
when designing your own traits.</p>
</div>
<h2 id="exercise-36"><a class="header" href="#exercise-36">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/10_assoc_vs_generic"><code>04_traits/10_assoc_vs_generic</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-1"><a class="header" href="#copying-values-pt-1">Copying values, pt. 1</a></h1>
<p>In the previous chapter we introduced ownership and borrowing.<br />
We stated, in particular, that:</p>
<ul>
<li>Every value in Rust has a single owner at any given time.</li>
<li>When a function takes ownership of a value ("it consumes it"), the caller can't use that value anymore.</li>
</ul>
<p>These restrictions can be somewhat limiting.<br />
Sometimes we might have to call a function that takes ownership of a value, but we still need to use
that value afterward.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str(", world!"); // error: value borrowed here after move
}
<span class="boring">}</span></code></pre></pre>
<p>That's where <code>Clone</code> comes in.</p>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p><code>Clone</code> is a trait defined in Rust's standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>Its method, <code>clone</code>, takes a reference to <code>self</code> and returns a new <strong>owned</strong> instance of the same type.</p>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Going back to the example above, we can use <code>clone</code> to create a new <code>String</code> instance before calling <code>consumer</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str(", world!"); // no error
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of giving ownership of <code>s</code> to <code>consumer</code>, we create a new <code>String</code> (by cloning <code>s</code>) and give
that to <code>consumer</code> instead.<br />
<code>s</code> remains valid and usable after the call to <code>consumer</code>.</p>
<h2 id="in-memory"><a class="header" href="#in-memory">In memory</a></h2>
<p>Let's look at what happened in memory in the example above.
When <code>let mut s: String::from("hello");</code> is executed, the memory looks like this:</p>
<pre><code class="language-text">                    s
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>When <code>let t = s.clone()</code> is executed, a whole new region is allocated on the heap to store a copy of the data:</p>
<pre><code class="language-text">                    s                                    t
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
</code></pre>
<p>If you're coming from a language like Java, you can think of <code>clone</code> as a way to create a deep copy of an object.</p>
<h2 id="implementing-clone"><a class="header" href="#implementing-clone">Implementing <code>Clone</code></a></h2>
<p>To make a type <code>Clone</code>-able, we have to implement the <code>Clone</code> trait for it.<br />
You almost always implement <code>Clone</code> by deriving it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyType {
    // fields
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler implements <code>Clone</code> for <code>MyType</code> as you would expect: it clones each field of <code>MyType</code> individually and
then constructs a new <code>MyType</code> instance using the cloned fields.<br />
Remember that you can use <code>cargo expand</code> (or your IDE) to explore the code generated by <code>derive</code> macros.</p>
<h2 id="exercise-37"><a class="header" href="#exercise-37">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone"><code>04_traits/11_clone</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-values-pt-2"><a class="header" href="#copying-values-pt-2">Copying values, pt. 2</a></h1>
<p>Let's consider the same example as before, but with a slight twist: using <code>u32</code> rather than <code>String</code> as a type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
<span class="boring">}</span></code></pre></pre>
<p>It'll compile without errors! What's going on here? What's the difference between <code>String</code> and <code>u32</code>
that makes the latter work without <code>.clone()</code>?</p>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<p><code>Copy</code> is another trait defined in Rust's standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>It is a marker trait, just like <code>Sized</code>.</p>
<p>If a type implements <code>Copy</code>, there's no need to call <code>.clone()</code> to create a new instance of the type:
Rust does it <strong>implicitly</strong> for you.<br />
<code>u32</code> is an example of a type that implements <code>Copy</code>, which is why the example above compiles without errors:
when <code>consumer(s)</code> is called, Rust creates a new <code>u32</code> instance by performing a <strong>bitwise copy</strong> of <code>s</code>,
and then passes that new instance to <code>consumer</code>. It all happens behind the scenes, without you having to do anything.</p>
<h2 id="what-can-be-copy"><a class="header" href="#what-can-be-copy">What can be <code>Copy</code>?</a></h2>
<p><code>Copy</code> is not equivalent to "automatic cloning", although it implies it.<br />
Types must meet a few requirements in order to be allowed to implement <code>Copy</code>.</p>
<p>First of all, it must implement <code>Clone</code>, since <code>Copy</code> is a subtrait of <code>Clone</code>.
This makes sense: if Rust can create a new instance of a type <em>implicitly</em>, it should
also be able to create a new instance <em>explicitly</em> by calling <code>.clone()</code>.</p>
<p>That's not all, though. A few more conditions must be met:</p>
<ol>
<li>The type doesn't manage any <em>additional</em> resources (e.g. heap memory, file handles, etc.) beyond the <code>std::mem::size_of</code>
bytes that it occupies in memory.</li>
<li>The type is not a mutable reference (<code>&amp;mut T</code>).</li>
</ol>
<p>If both conditions are met, then Rust can safely create a new instance of the type by performing a <strong>bitwise copy</strong>
of the original instance—this is often referred to as a <code>memcpy</code> operation, after the C standard library function
that performs the bitwise copy.</p>
<h3 id="case-study-1-string"><a class="header" href="#case-study-1-string">Case study 1: <code>String</code></a></h3>
<p><code>String</code> is a type that doesn't implement <code>Copy</code>.<br />
Why? Because it manages an additional resource: the heap-allocated memory buffer that stores the string's data.</p>
<p>Let's imagine that Rust allowed <code>String</code> to implement <code>Copy</code>.<br />
Then, when a new <code>String</code> instance is created by performing a bitwise copy of the original instance, both the original
and the new instance would point to the same memory buffer:</p>
<pre><code class="language-text">              s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+
</code></pre>
<p>This is bad!
Both <code>String</code> instances would try to free the memory buffer when they go out of scope,
leading to a double-free error.
You could also create two distinct <code>&amp;mut String</code> references that point to the same memory buffer,
violating Rust's borrowing rules.</p>
<h3 id="case-study-2-u32"><a class="header" href="#case-study-2-u32">Case study 2: <code>u32</code></a></h3>
<p><code>u32</code> implements <code>Copy</code>. All integer types do, in fact.<br />
An integer is "just" the bytes that represent the number in memory. There's nothing more!
If you copy those bytes, you get another perfectly valid integer instance.
Nothing bad can happen, so Rust allows it.</p>
<h3 id="case-study-3-mut-u32"><a class="header" href="#case-study-3-mut-u32">Case study 3: <code>&amp;mut u32</code></a></h3>
<p>When we introduced ownership and mutable borrows, we stated one rule quite clearly: there
can only ever be <em>one</em> mutable borrow of a value at any given time.<br />
That's why <code>&amp;mut u32</code> doesn't implement <code>Copy</code>, even though <code>u32</code> does.</p>
<p>If <code>&amp;mut u32</code> implemented <code>Copy</code>, you could create multiple mutable references to
the same value and modify it in multiple places at the same time.
That'd be a violation of Rust's borrowing rules!
It follows that <code>&amp;mut T</code> never implements <code>Copy</code>, no matter what <code>T</code> is.</p>
<h2 id="implementing-copy"><a class="header" href="#implementing-copy">Implementing <code>Copy</code></a></h2>
<p>In most cases, you don't need to manually implement <code>Copy</code>.
You can just derive it, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-38"><a class="header" href="#exercise-38">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy"><code>04_traits/12_copy</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> trait</a></h1>
<p>When we introduced <a href="04_traits/../03_ticket_v1/11_destructor.html">destructors</a>,
we mentioned that the <code>drop</code> function:</p>
<ol>
<li>reclaims the memory occupied by the type (i.e. <code>std::mem::size_of</code> bytes)</li>
<li>cleans up any additional resources that the value might be managing (e.g. the heap buffer of a <code>String</code>)</li>
</ol>
<p>Step 2. is where the <code>Drop</code> trait comes in.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Drop</code> trait is a mechanism for you to define <em>additional</em> cleanup logic for your types,
beyond what the compiler does for you automatically.<br />
Whatever you put in the <code>drop</code> method will be executed when the value goes out of scope.</p>
<h2 id="drop-and-copy"><a class="header" href="#drop-and-copy"><code>Drop</code> and <code>Copy</code></a></h2>
<p>When talking about the <code>Copy</code> trait, we said that a type can't implement <code>Copy</code> if it
manages additional resources beyond the <code>std::mem::size_of</code> bytes that it occupies in memory.</p>
<p>You might wonder: how does the compiler know if a type manages additional resources?
That's right: <code>Drop</code> trait implementations!<br />
If your type has an explicit <code>Drop</code> implementation, the compiler will assume
that your type has additional resources attached to it and won't allow you to implement <code>Copy</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a unit struct, i.e. a struct with no fields.
#[derive(Clone, Copy)]
struct MyType;

impl Drop for MyType {
    fn drop(&amp;mut self) {
       // We don't need to do anything here,
       // it's enough to have an "empty" Drop implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will complain with this error message:</p>
<pre><code class="language-text">error[E0184]: the trait `Copy` cannot be implemented for this type; the type has a destructor
 --&gt; src/lib.rs:2:17
  |
2 | #[derive(Clone, Copy)]
  |                 ^^^^ `Copy` not allowed on types with destructors
</code></pre>
<h2 id="exercise-39"><a class="header" href="#exercise-39">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/13_drop"><code>04_traits/13_drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h1>
<p>We've covered quite a few different traits in this chapter—and we've only scratched the surface!
It may feel like you have a lot to remember, but don't worry: you'll bump into these traits
so often when writing Rust code that they'll soon become second nature.</p>
<h2 id="closing-thoughts"><a class="header" href="#closing-thoughts">Closing thoughts</a></h2>
<p>Traits are powerful, but don't overuse them.<br />
A few guidelines to keep in mind:</p>
<ul>
<li>Don't make a function generic if it is always invoked with a single type. It introduces indirection in your
codebase, making it harder to understand and maintain.</li>
<li>Don't create a trait if you only have one implementation. It's a sign that the trait is not needed.</li>
<li>Implement standard traits for your types (<code>Debug</code>, <code>PartialEq</code>, etc.) whenever it makes sense.
It will make your types more idiomatic and easier to work with, unlocking a lot of functionality provided
by the standard library and ecosystem crates.</li>
<li>Implement traits from third-party crates if you need the functionality they unlock within their ecosystem.</li>
<li>Beware of making code generic solely to use mocks in your tests. The maintainability cost of this approach
can be high, and it's often better to use a different testing strategy. Check out the
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">testing masterclass</a>
for details on high-fidelity testing.</li>
</ul>
<h2 id="testing-your-knowledge"><a class="header" href="#testing-your-knowledge">Testing your knowledge</a></h2>
<p>Before moving on, let's go through one last exercise to consolidate what we've learned.
You'll have minimal guidance this time—just the exercise description and the tests to guide you.</p>
<h2 id="exercise-40"><a class="header" href="#exercise-40">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/14_outro"><code>04_traits/14_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-a-ticket-pt-2"><a class="header" href="#modelling-a-ticket-pt-2">Modelling A Ticket, pt. 2</a></h1>
<p>The <code>Ticket</code> struct we worked on in the previous chapters is a good start,
but it still screams "I'm a beginner Rustacean!".</p>
<p>We'll use this chapter to refine our Rust domain modelling skills.
We'll need to introduce a few more concepts along the way:</p>
<ul>
<li><code>enum</code>s, one of Rust's most powerful features for data modeling</li>
<li>The <code>Option</code> type, to model nullable values</li>
<li>The <code>Result</code> type, to model recoverable errors</li>
<li>The <code>Debug</code> and <code>Display</code> traits, for printing</li>
<li>The <code>Error</code> trait, to mark error types</li>
<li>The <code>TryFrom</code> and <code>TryInto</code> traits, for fallible conversions</li>
<li>Rust's package system, explaining what's a library, what's a binary, how to use third-party crates</li>
</ul>
<h2 id="exercise-41"><a class="header" href="#exercise-41">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/00_intro"><code>05_ticket_v2/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>Based on the validation logic you wrote <a href="05_ticket_v2/../03_ticket_v1/02_validation.html">in a previous chapter</a>,
there are only a few valid statuses for a ticket: <code>To-Do</code>, <code>InProgress</code> and <code>Done</code>.<br />
This is not obvious if we look at the <code>status</code> field in the <code>Ticket</code> struct or at the type of the <code>status</code>
parameter in the <code>new</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Ticket {
    title: String,
    description: String,
    status: String,
}

impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In both cases we're using <code>String</code> to represent the <code>status</code> field.
<code>String</code> is a very general type—it doesn't immediately convey the information that the <code>status</code> field
has a limited set of possible values. Even worse, the caller of <code>Ticket::new</code> will only find out <strong>at runtime</strong>
if the status they provided is valid or not.</p>
<p>We can do better than that with <strong>enumerations</strong>.</p>
<h2 id="enum"><a class="header" href="#enum"><code>enum</code></a></h2>
<p>An enumeration is a type that can have a fixed set of values, called <strong>variants</strong>.<br />
In Rust, you define an enumeration using the <code>enum</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>enum</code>, just like <code>struct</code>, defines <strong>a new Rust type</strong>.</p>
<h2 id="exercise-42"><a class="header" href="#exercise-42">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/01_enum"><code>05_ticket_v2/01_enum</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match"><code>match</code></a></h1>
<p>You may be wondering—what can you actually <strong>do</strong> with an enum?<br />
The most common operation is to <strong>match</strong> on it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done
}

impl Status {
    fn is_done(&amp;self) -&gt; bool {
        match self {
            Status::Done =&gt; true,
            // The `|` operator lets you match multiple patterns.
            // It reads as "either `Status::ToDo` or `Status::InProgress`".
            Status::InProgress | Status::ToDo =&gt; false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>match</code> statement that lets you compare a Rust value against a series of <strong>patterns</strong>.<br />
You can think of it as a type-level <code>if</code>. If <code>status</code> is a <code>Done</code> variant, execute the first block;
if it's a <code>InProgress</code> or <code>ToDo</code> variant, execute the second block.</p>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>There's one key detail here: <code>match</code> is <strong>exhaustive</strong>. You must handle all enum variants.<br />
If you forget to handle a variant, Rust will stop you <strong>at compile-time</strong> with an error.</p>
<p>E.g. if we forget to handle the <code>ToDo</code> variant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match self {
    Status::Done =&gt; true,
    Status::InProgress =&gt; false,
}
<span class="boring">}</span></code></pre></pre>
<p>the compiler will complain:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `ToDo` not covered
 --&gt; src/main.rs:5:9
  |
5 |     match status {
  |     ^^^^^^^^^^^^ pattern `ToDo` not covered
</code></pre>
<p>This is a big deal!<br />
Codebases evolve over time—you might add a new status down the line, e.g. <code>Blocked</code>. The Rust compiler
will emit an error for every single <code>match</code> statement that's missing logic for the new variant.
That's why Rust developers often sing the praises of "compiler-driven refactoring"—the compiler tells you
what to do next, you just have to fix what it reports.</p>
<h2 id="catch-all"><a class="header" href="#catch-all">Catch-all</a></h2>
<p>If you don't care about one or more variants, you can use the <code>_</code> pattern as a catch-all:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::Done =&gt; true,
    _ =&gt; false
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>_</code> pattern matches anything that wasn't matched by the previous patterns.</p>
<h2 id="exercise-43"><a class="header" href="#exercise-43">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match"><code>05_ticket_v2/02_match</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants-can-hold-data"><a class="header" href="#variants-can-hold-data">Variants can hold data</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Our <code>Status</code> enum is what's usually called a <strong>C-style enum</strong>.<br />
Each variant is a simple label, a bit like a named constant. You can find this kind of enum in many programming
languages, like C, C++, Java, C#, Python, etc.</p>
<p>Rust enums can go further though. We can <strong>attach data to each variant</strong>.</p>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<p>Let's say that we want to store the name of the person who's currently working on a ticket.<br />
We would only have this information if the ticket is in progress. It wouldn't be there for a to-do ticket or
a done ticket.
We can model this by attaching a <code>String</code> field to the <code>InProgress</code> variant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress {
        assigned_to: String,
    },
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>InProgress</code> is now a <strong>struct-like variant</strong>.<br />
The syntax mirrors, in fact, the one we used to define a struct—it's just "inlined" inside the enum, as a variant.</p>
<h2 id="accessing-variant-data"><a class="header" href="#accessing-variant-data">Accessing variant data</a></h2>
<p>If we try to access <code>assigned_to</code> on a <code>Status</code> instance,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status: Status = /* */;

// This won't compile
println!("Assigned to: {}", status.assigned_to);
<span class="boring">}</span></code></pre></pre>
<p>the compiler will stop us:</p>
<pre><code class="language-text">error[E0609]: no field `assigned_to` on type `Status`
 --&gt; src/main.rs:5:40
  |
5 |     println!("Assigned to: {}", status.assigned_to);
  |                                        ^^^^^^^^^^^ unknown field
</code></pre>
<p><code>assigned_to</code> is <strong>variant-specific</strong>, it's not available on all <code>Status</code> instances.<br />
To access <code>assigned_to</code>, we need to use <strong>pattern matching</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to } =&gt; {
        println!("Assigned to: {}", assigned_to);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bindings"><a class="header" href="#bindings">Bindings</a></h2>
<p>In the match pattern <code>Status::InProgress { assigned_to }</code>, <code>assigned_to</code> is a <strong>binding</strong>.<br />
We're <strong>destructuring</strong> the <code>Status::InProgress</code> variant and binding the <code>assigned_to</code> field to
a new variable, also named <code>assigned_to</code>.<br />
If we wanted, we could bind the field to a different variable name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to: person } =&gt; {
        println!("Assigned to: {}", person);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-44"><a class="header" href="#exercise-44">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/03_variants_with_data"><code>05_ticket_v2/03_variants_with_data</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-branching"><a class="header" href="#concise-branching">Concise branching</a></h1>
<p>Your solution to the previous exercise probably looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        match &amp;self.status {
            Status::InProgress { assigned_to } =&gt; assigned_to,
            Status::Done | Status::ToDo =&gt; {
                panic!("Only `In-Progress` tickets can be assigned to someone"),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You only care about the <code>Status::InProgress</code> variant.
Do you really need to match on all the other variants?</p>
<p>New constructs to the rescue!</p>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p>The <code>if let</code> construct allows you to match on a single variant of an enum,
without having to handle all the other variants.</p>
<p>Here's how you can use <code>if let</code> to simplify the <code>assigned_to</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        if let Status::InProgress { assigned_to } = &amp;self.status {
            assigned_to
        } else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="letelse"><a class="header" href="#letelse"><code>let/else</code></a></h2>
<p>If the <code>else</code> branch is meant to return early (a panic counts as returning early!),
you can use the <code>let/else</code> construct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        let Status::InProgress { assigned_to } = &amp;self.status else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        };
        assigned_to
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It allows you to assign the destructured variable without incurring
any "right drift", i.e. the variable is assigned at the same indentation level
as the code that precedes it.</p>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>Both <code>if let</code> and <code>let/else</code> are idiomatic Rust constructs.<br />
Use them as you see fit to improve the readability of your code,
but don't overdo it: <code>match</code> is always there when you need it.</p>
<h2 id="exercise-45"><a class="header" href="#exercise-45">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/04_if_let"><code>05_ticket_v2/04_if_let</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullability"><a class="header" href="#nullability">Nullability</a></h1>
<p>Our implementation of the <code>assigned</code> method is fairly blunt: panicking for to-do and done tickets is far from ideal.<br />
We can do better using <strong>Rust's <code>Option</code> type</strong>.</p>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p><code>Option</code> is a Rust type that represents <strong>nullable values</strong>.<br />
It is an enum, defined in Rust's standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option</code> encodes the idea that a value might be present (<code>Some(T)</code>) or absent (<code>None</code>).<br />
It also forces you to <strong>explicitly handle both cases</strong>. You'll get a compiler error if you are working with
a nullable value and you forget to handle the <code>None</code> case.<br />
This is a significant improvement over "implicit" nullability in other languages, where you can forget to check
for <code>null</code> and thus trigger a runtime error.</p>
<h2 id="options-definition"><a class="header" href="#options-definition"><code>Option</code>'s definition</a></h2>
<p><code>Option</code>'s definition uses a Rust construct that you haven't seen before: <strong>tuple-like variants</strong>.</p>
<h3 id="tuple-like-variants"><a class="header" href="#tuple-like-variants">Tuple-like variants</a></h3>
<p><code>Option</code> has two variants: <code>Some(T)</code> and <code>None</code>.<br />
<code>Some</code> is a <strong>tuple-like variant</strong>: it's a variant that holds <strong>unnamed fields</strong>.</p>
<p>Tuple-like variants are often used when there is a single field to store, especially when we're looking at a
"wrapper" type like <code>Option</code>.</p>
<h3 id="tuple-like-structs"><a class="header" href="#tuple-like-structs">Tuple-like structs</a></h3>
<p>They're not specific to enums—you can define tuple-like structs too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
<span class="boring">}</span></code></pre></pre>
<p>You can then access the two fields of a <code>Point</code> instance using their positional index:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = Point(3, 4);
let x = point.0;
let y = point.1;
<span class="boring">}</span></code></pre></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>It's weird say that something is tuple-like when we haven't seen tuples yet!<br />
Tuples are another example of a primitive Rust type.
They group together a fixed number of values with (potentially different) types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Two values, same type
let first: (i32, i32) = (3, 4);
// Three values, different types
let second: (i32, u32, u8) = (-42, 3, 8);
<span class="boring">}</span></code></pre></pre>
<p>The syntax is simple: you list the types of the values between parentheses, separated by commas.
You can access the fields of a tuple using the dot notation and the field index:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);
<span class="boring">}</span></code></pre></pre>
<p>Tuples are a convenient way of grouping values together when you can't be bothered to define a dedicated struct type.</p>
<h2 id="exercise-46"><a class="header" href="#exercise-46">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/05_nullability"><code>05_ticket_v2/05_nullability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallibility"><a class="header" href="#fallibility">Fallibility</a></h1>
<p>Let's revisit the <code>Ticket::new</code> function from the previous exercise:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: Status) -&gt; Ticket {
        if title.is_empty() {
            panic!("Title cannot be empty");
        }
        if title.len() &gt; 50 {
            panic!("Title cannot be longer than 50 bytes");
        }
        if description.is_empty() {
            panic!("Description cannot be empty");
        }
        if description.len() &gt; 500 {
            panic!("Description cannot be longer than 500 bytes");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As soon as one of the checks fails, the function panics.
This is not ideal, as it doesn't give the caller a chance to <strong>handle the error</strong>.</p>
<p>It's time to introduce the <code>Result</code> type, Rust's primary mechanism for error handling.</p>
<h2 id="the-result-type"><a class="header" href="#the-result-type">The <code>Result</code> type</a></h2>
<p>The <code>Result</code> type is an enum defined in the standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>It has two variants:</p>
<ul>
<li><code>Ok(T)</code>: represents a successful operation. It holds <code>T</code>, the output of the operation.</li>
<li><code>Err(E)</code>: represents a failed operation. It holds <code>E</code>, the error that occurred.</li>
</ul>
<p>Both <code>Ok</code> and <code>Err</code> are generic, allowing you to specify your own types for the success and error cases.</p>
<h2 id="no-exceptions"><a class="header" href="#no-exceptions">No exceptions</a></h2>
<p>Recoverable errors in Rust are <strong>represented as values</strong>.<br />
They're just an instance of a type, being passed around and manipulated like any other value.
This is a significant difference from other languages, such as Python or C#, where <strong>exceptions</strong> are used to signal errors.</p>
<p>Exceptions create a separate control flow path that can be hard to reason about.<br />
You don't know, just by looking at a function's signature, if it can throw an exception or not.
You don't know, just by looking at a function's signature, <strong>which</strong> exception types it can throw.<br />
You must either read the function's documentation or look at its implementation to find out.</p>
<p>Exception handling logic has very poor locality: the code that throws the exception is far removed from the code
that catches it, and there's no direct link between the two.</p>
<h2 id="fallibility-is-encoded-in-the-type-system"><a class="header" href="#fallibility-is-encoded-in-the-type-system">Fallibility is encoded in the type system</a></h2>
<p>Rust, with <code>Result</code>, forces you to <strong>encode fallibility in the function's signature</strong>.<br />
If a function can fail (and you want the caller to have a shot at handling the error), it must return a <code>Result</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just by looking at the signature, you know that this function can fail.
// You can also inspect `ParseIntError` to see what kind of failures to expect.
fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>That's the big advantage of <code>Result</code>: it makes fallibility explicit.</p>
<p>Keep in mind, though, that panics exist. They aren't tracked by the type system, just like exceptions in other languages.
But they're meant for <strong>unrecoverable errors</strong> and should be used sparingly.</p>
<h2 id="exercise-47"><a class="header" href="#exercise-47">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/06_fallibility"><code>05_ticket_v2/06_fallibility</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwrapping"><a class="header" href="#unwrapping">Unwrapping</a></h1>
<p><code>Ticket::new</code> now returns a <code>Result</code> instead of panicking on invalid inputs.<br />
What does this mean for the caller?</p>
<h2 id="failures-cant-be-implicitly-ignored"><a class="header" href="#failures-cant-be-implicitly-ignored">Failures can't be (implicitly) ignored</a></h2>
<p>Unlike exceptions, Rust's <code>Result</code> forces you to <strong>handle errors at the call site</strong>.<br />
If you call a function that returns a <code>Result</code>, Rust won't allow you to implicitly ignore the error case.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}

// This won't compile: we're not handling the error case.
// We must either use `match` or one of the combinators provided by `Result`
// to "unwrap" the success value or handle the error.
let number = parse_int("42") + 2;
<span class="boring">}</span></code></pre></pre>
<h2 id="you-got-a-result-now-what"><a class="header" href="#you-got-a-result-now-what">You got a <code>Result</code>. Now what?</a></h2>
<p>When you call a function that returns a <code>Result</code>, you have two key options:</p>
<ul>
<li>Panic if the operation failed.
This is done using either the <code>unwrap</code> or <code>expect</code> methods.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Panics if `parse_int` returns an `Err`.
let number = parse_int("42").unwrap();
// `expect` lets you specify a custom panic message.
let number = parse_int("42").expect("Failed to parse integer");
<span class="boring">}</span></code></pre></pre>
</li>
<li>Destructure the <code>Result</code> using a <code>match</code> expression to deal with the error case explicitly.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match parse_int("42") {
    Ok(number) =&gt; println!("Parsed number: {}", number),
    Err(err) =&gt; eprintln!("Error: {}", err),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="exercise-48"><a class="header" href="#exercise-48">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/07_unwrap"><code>05_ticket_v2/07_unwrap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-enums"><a class="header" href="#error-enums">Error enums</a></h1>
<p>Your solution to the previous exercise may have felt awkward: matching on strings is not ideal!<br />
A colleague might rework the error messages returned by <code>Ticket::new</code> (e.g. to improve readability) and,
all of a sudden, your calling code would break.</p>
<p>You already know the machinery required to fix this: enums!</p>
<h2 id="reacting-to-errors"><a class="header" href="#reacting-to-errors">Reacting to errors</a></h2>
<p>When you want to allow the caller to behave differently based on the specific error that occurred, you can
use an enum to represent the different error cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An error enum to represent the different error cases
// that may occur when parsing a `u32` from a string.
enum U32ParseError {
    NotANumber,
    TooLarge,
    Negative,
}
<span class="boring">}</span></code></pre></pre>
<p>Using an error enum, you're encoding the different error cases in the type system—they become part of the
signature of the fallible function.<br />
This simplifies error handling for the caller, as they can use a <code>match</code> expression to react to the different
error cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match s.parse_u32() {
    Ok(n) =&gt; n,
    Err(U32ParseError::Negative) =&gt; 0,
    Err(U32ParseError::TooLarge) =&gt; u32::MAX,
    Err(U32ParseError::NotANumber) =&gt; {
        panic!("Not a number: {}", s);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-49"><a class="header" href="#exercise-49">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/08_error_enums"><code>05_ticket_v2/08_error_enums</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-trait"><a class="header" href="#error-trait">Error trait</a></h1>
<h2 id="error-reporting"><a class="header" href="#error-reporting">Error reporting</a></h2>
<p>In the previous exercise you had to destructure the <code>InvalidTitle</code> variant to extract the error message and
pass it to the <code>panic!</code> macro.<br />
This is a (rudimentary) example of <strong>error reporting</strong>: transforming an error type into a representation that can be
shown to a user, a service operator, or a developer.</p>
<p>It's not practical for each Rust developer to come up with their own error reporting strategy: it'd a waste of time
and it wouldn't compose well across projects.
That's why Rust provides the <code>std::error::Error</code> trait.</p>
<h2 id="the-error-trait"><a class="header" href="#the-error-trait">The <code>Error</code> trait</a></h2>
<p>There are no constraints on the type of the <code>Err</code> variant in a <code>Result</code>, but it's a good practice to use a type
that implements the <code>Error</code> trait.
<code>Error</code> is the cornerstone of Rust's error handling story:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified definition of the `Error` trait
pub trait Error: Debug + Display {}
<span class="boring">}</span></code></pre></pre>
<p>You might recall the <code>:</code> syntax from <a href="05_ticket_v2/../04_traits/08_sized.html">the <code>Sized</code> trait</a>—it's used to specify <strong>supertraits</strong>.
For <code>Error</code>, there are two supertraits: <code>Debug</code> and <code>Display</code>. If a type wants to implement <code>Error</code>, it must also
implement <code>Debug</code> and <code>Display</code>.</p>
<h2 id="display-and-debug"><a class="header" href="#display-and-debug"><code>Display</code> and <code>Debug</code></a></h2>
<p>We've already encountered the <code>Debug</code> trait in <a href="05_ticket_v2/../04_traits/04_derive.html">a previous exercise</a>—it's the trait used by
<code>assert_eq!</code> to display the values of the variables it's comparing when the assertion fails.</p>
<p>From a "mechanical" perspective, <code>Display</code> and <code>Debug</code> are identical—they encode how a type should be converted
into a string-like representation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Debug`
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

// `Display`
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The difference is in their <em>purpose</em>: <code>Display</code> returns a representation that's meant for "end-users",
while <code>Debug</code> provides a low-level representation that's more suitable to developers and service operators.<br />
That's why <code>Debug</code> can be automatically implemented using the <code>#[derive(Debug)]</code> attribute, while <code>Display</code>
<strong>requires</strong> a manual implementation.</p>
<h2 id="exercise-50"><a class="header" href="#exercise-50">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/09_error_trait"><code>05_ticket_v2/09_error_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-binaries"><a class="header" href="#libraries-and-binaries">Libraries and binaries</a></h1>
<p>It took a bit of code to implement the <code>Error</code> trait for <code>TicketNewError</code>, didn't it?<br />
A manual <code>Display</code> implementation, plus an <code>Error</code> impl block.</p>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.<br />
But we're getting ahead of ourselves: <code>thiserror</code> is a third-party crate, it'd be our first dependency!</p>
<p>Let's take a step back to talk about Rust's packaging system before we dive into dependencies.</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a package?</a></h2>
<p>A Rust package is defined by the <code>[package]</code> section in a <code>Cargo.toml</code> file, also known as its <strong>manifest</strong>.
Within <code>[package]</code> you can set the package's metadata, such as its name and version.</p>
<p>Go check the <code>Cargo.toml</code> file in the directory of this section's exercise!</p>
<h2 id="what-is-a-crate"><a class="header" href="#what-is-a-crate">What is a crate?</a></h2>
<p>Inside a package, you can have one or more <strong>crates</strong>, also known as <strong>targets</strong>.<br />
The two most common crate types are <strong>binary crates</strong> and <strong>library crates</strong>.</p>
<h3 id="binaries"><a class="header" href="#binaries">Binaries</a></h3>
<p>A binary is a program that can be compiled to an <strong>executable file</strong>.<br />
It must include a function named <code>main</code>—the program's entry point. <code>main</code> is invoked when the program is executed.</p>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p>Libraries, on the other hand, are not executable on their own. You can't <em>run</em> a library,
but you can <em>import its code</em> from another package that depends on it.<br />
A library groups together code (i.e. functions, types, etc.) that can be leveraged by other packages as a <strong>dependency</strong>.</p>
<p>All the exercises you've solved so far have been structured as libraries, with a test suite attached to them.</p>
<h3 id="conventions"><a class="header" href="#conventions">Conventions</a></h3>
<p>There are some conventions around Rust packages that you need to keep in mind:</p>
<ul>
<li>The package's source code is usually located in the <code>src</code> directory.</li>
<li>If there's a <code>src/lib.rs</code> file, <code>cargo</code> will infer that the package contains a library crate.</li>
<li>If there's a <code>src/main.rs</code> file, <code>cargo</code> will infer that the package contains a binary crate.</li>
</ul>
<p>You can override these defaults by explicitly declaring your targets in the <code>Cargo.toml</code> file—see
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets"><code>cargo</code>'s documentation</a> for more details.</p>
<p>Keep in mind that while a package can contain multiple crates, it can only contain one library crate.</p>
<h2 id="scaffolding-a-new-package"><a class="header" href="#scaffolding-a-new-package">Scaffolding a new package</a></h2>
<p>You can use <code>cargo</code> to scaffold a new package:</p>
<pre><code class="language-bash">cargo new my-binary
</code></pre>
<p>This will create a new folder, <code>my-binary</code>, containing a new Rust package with the same name and a single
binary crate inside. If you want to create a library crate instead, you can use the <code>--lib</code> flag:</p>
<pre><code class="language-bash">cargo new my-library --lib
</code></pre>
<h2 id="exercise-51"><a class="header" href="#exercise-51">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/10_packages"><code>05_ticket_v2/10_packages</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>A package can depend on other packages by listing them in the <code>[dependencies]</code> section of its <code>Cargo.toml</code> file.<br />
The most common way to specify a dependency is by providing its name and version:</p>
<pre><code class="language-toml">[dependencies]
thiserror = "1"
</code></pre>
<p>This will add <code>thiserror</code> as a dependency to your package, with a <strong>minimum</strong> version of <code>1.0.0</code>.
<code>thiserror</code> will be pulled from <a href="https://crates.io">crates.io</a>, Rust's official package registry.
When you run <code>cargo build</code>, <code>cargo</code> will go through a few stages:</p>
<ul>
<li>Dependency resolution</li>
<li>Downloading the dependencies</li>
<li>Compiling your project (your own code and the dependencies)</li>
</ul>
<p>Dependency resolution is skipped if your project has a <code>Cargo.lock</code> file and your manifest files are unchanged.
A lockfile is automatically generated by <code>cargo</code> after a successful round of dependency resolution: it contains
the exact versions of all dependencies used in your project, and is used to ensure that the same versions are
consistently used across different builds (e.g. in CI). If you're working on a project with multiple developers,
you should commit the <code>Cargo.lock</code> file to your version control system.</p>
<p>You can use <code>cargo update</code> to update the <code>Cargo.lock</code> file with the latest (compatible) versions of all your dependencies.</p>
<h3 id="path-dependencies"><a class="header" href="#path-dependencies">Path dependencies</a></h3>
<p>You can also specify a dependency using a <strong>path</strong>. This is useful when you're working on multiple local packages.</p>
<pre><code class="language-toml">[dependencies]
my-library = { path = "../my-library" }
</code></pre>
<p>The path is relative to the <code>Cargo.toml</code> file of the package that's declaring the dependency.</p>
<h3 id="other-sources"><a class="header" href="#other-sources">Other sources</a></h3>
<p>Check out the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo documentation</a> for more
details on where you can get dependencies from and how to specify them in your <code>Cargo.toml</code> file.</p>
<h2 id="dev-dependencies"><a class="header" href="#dev-dependencies">Dev dependencies</a></h2>
<p>You can also specify dependencies that are only needed for development—i.e. they only get pulled in when you're
running <code>cargo test</code>.<br />
They go in the <code>[dev-dependencies]</code> section of your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dev-dependencies]
static_assertions = "1.1.0"
</code></pre>
<p>We've been using a few of these throughout the book to shorten our tests.</p>
<h2 id="exercise-52"><a class="header" href="#exercise-52">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/11_dependencies"><code>05_ticket_v2/11_dependencies</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thiserror"><a class="header" href="#thiserror"><code>thiserror</code></a></h1>
<p>That was a bit of detour, wasn't it? But a necessary one!<br />
Let's get back on track now: custom error types and <code>thiserror</code>.</p>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom error types</a></h2>
<p>We've seen how to implement the <code>Error</code> trait "manually" for a custom error type.<br />
Imagine that you have to do this for most error types in your codebase. That's a lot of boilerplate, isn't it?</p>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(thiserror::Error, Debug)]
enum TicketNewError {
    #[error("{0}")]
    TitleError(String),
    #[error("{0}")]
    DescriptionError(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="you-can-write-your-own-macros"><a class="header" href="#you-can-write-your-own-macros">You can write your own macros</a></h2>
<p>All the <code>derive</code> macros we've seen so far were provided by the Rust standard library.<br />
<code>thiserror::Error</code> is the first example of a <strong>third-party</strong> <code>derive</code> macro.</p>
<p><code>derive</code> macros are a subset of <strong>procedural macros</strong>, a way to generate Rust code at compile time.
We won't get into the details of how to write a procedural macro in this course, but it's important
to know that you can write your own!<br />
A topic to approach in a more advanced Rust course.</p>
<h2 id="custom-syntax"><a class="header" href="#custom-syntax">Custom syntax</a></h2>
<p>Each procedural macro can define its own syntax, which is usually explained in the crate's documentation.
In the case of <code>thiserror</code>, we have:</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>: this is the syntax to derive the <code>Error</code> trait for a custom error type, helped by <code>thiserror</code>.</li>
<li><code>#[error("{0}")]</code>: this is the syntax to define a <code>Display</code> implementation for each variant of the custom error type.
<code>{0}</code> is replaced by the zero-th field of the variant (<code>String</code>, in this case) when the error is displayed.</li>
</ul>
<h2 id="exercise-53"><a class="header" href="#exercise-53">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/12_thiserror"><code>05_ticket_v2/12_thiserror</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-and-tryinto"><a class="header" href="#tryfrom-and-tryinto"><code>TryFrom</code> and <code>TryInto</code></a></h1>
<p>In the previous chapter we looked at the <a href="05_ticket_v2/../04_traits/09_from.html"><code>From</code> and <code>Into</code> traits</a>,
Rust's idiomatic interfaces for <strong>infallible</strong> type conversions.<br />
But what if the conversion is not guaranteed to succeed?</p>
<p>We now know enough about errors to discuss the <strong>fallible</strong> counterparts of <code>From</code> and <code>Into</code>:
<code>TryFrom</code> and <code>TryInto</code>.</p>
<h2 id="tryfrom-and-tryinto-1"><a class="header" href="#tryfrom-and-tryinto-1"><code>TryFrom</code> and <code>TryInto</code></a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> are defined in the <code>std::convert</code> module, just like <code>From</code> and <code>Into</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TryFrom&lt;T&gt;: Sized {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

pub trait TryInto&lt;T&gt;: Sized {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The main difference between <code>From</code>/<code>Into</code> and <code>TryFrom</code>/<code>TryInto</code> is that the latter return a <code>Result</code> type.<br />
This allows the conversion to fail, returning an error instead of panicking.</p>
<h2 id="selferror"><a class="header" href="#selferror"><code>Self::Error</code></a></h2>
<p>Both <code>TryFrom</code> and <code>TryInto</code> have an associated <code>Error</code> type.
This allows each implementation to specify its own error type, ideally the most appropriate for the conversion
being attempted.</p>
<p><code>Self::Error</code> is a way to refer to the <code>Error</code> associated type defined in the trait itself.</p>
<h2 id="duality"><a class="header" href="#duality">Duality</a></h2>
<p>Just like <code>From</code> and <code>Into</code>, <code>TryFrom</code> and <code>TryInto</code> are dual traits.<br />
If you implement <code>TryFrom</code> for a type, you get <code>TryInto</code> for free.</p>
<h2 id="exercise-54"><a class="header" href="#exercise-54">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/13_try_from"><code>05_ticket_v2/13_try_from</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errorsource"><a class="header" href="#errorsource"><code>Error::source</code></a></h1>
<p>There's one more thing we need to talk about to complete our coverage of the <code>Error</code> trait: the <code>source</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full definition this time!
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>source</code> method is a way to access the <strong>error cause</strong>, if any.<br />
Errors are often chained, meaning that one error is the cause of another: you have a high-level error (e.g.
cannot connect to the database) that is caused by a lower-level error (e.g. can't resolve the database hostname).
The <code>source</code> method allows you to "walk" the full chain of errors, often used when capturing error context in logs.</p>
<h2 id="implementing-source"><a class="header" href="#implementing-source">Implementing <code>source</code></a></h2>
<p>The <code>Error</code> trait provides a default implementation that always returns <code>None</code> (i.e. no underlying cause). That's why
you didn't have to care about <code>source</code> in the previous exercises.<br />
You can override this default implementation to provide a cause for your error type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct DatabaseError {
    source: std::io::Error
}

impl std::fmt::Display for DatabaseError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Failed to connect to the database")
    }
}

impl std::error::Error for DatabaseError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>DatabaseError</code> wraps an <code>std::io::Error</code> as its source.
We then override the <code>source</code> method to return this source when called.</p>
<h2 id="dyn-error--static"><a class="header" href="#dyn-error--static"><code>&amp;(dyn Error + 'static)</code></a></h2>
<p>What's this <code>&amp;(dyn Error + 'static)</code> type?<br />
Let's unpack it:</p>
<ul>
<li><code>dyn Error</code> is a <strong>trait object</strong>. It's a way to refer to any type that implements the <code>Error</code> trait.</li>
<li><code>'static</code> is a special <strong>lifetime specifier</strong>.
<code>'static</code> implies that the reference is valid for "as long as we need it", i.e. the entire program execution.</li>
</ul>
<p>Combined: <code>&amp;(dyn Error + 'static)</code> is a reference to a trait object that implements the <code>Error</code> trait
and is valid for the entire program execution.</p>
<p>Don't worry too much about either of these concepts for now. We'll cover them in more detail in future chapters.</p>
<h2 id="implementing-source-using-thiserror"><a class="header" href="#implementing-source-using-thiserror">Implementing <code>source</code> using <code>thiserror</code></a></h2>
<p><code>thiserror</code> provides three ways to automatically implement <code>source</code> for your error types:</p>
<ul>
<li>A field named <code>source</code> will automatically be used as the source of the error.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        source: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A field annotated with the <code>#[source]</code> attribute will automatically be used as the source of the error.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[source]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A field annotated with the <code>#[from]</code> attribute will automatically be used as the source of the error <strong>and</strong>
<code>thiserror</code> will automatically generate a <code>From</code> implementation to convert the annotated type into your error type.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[from]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="the--operator"><a class="header" href="#the--operator">The <code>?</code> operator</a></h2>
<p>The <code>?</code> operator is a shorthand for propagating errors.<br />
When used in a function that returns a <code>Result</code>, it will return early with an error if the <code>Result</code> is <code>Err</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open("file.txt")?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = match File::open("file.txt") {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            return Err(e);
        }
    };
    let mut contents = String::new();
    match file.read_to_string(&amp;mut contents) {
        Ok(_) =&gt; (),
        Err(e) =&gt; {
            return Err(e);
        }
    }
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>?</code> operator to shorten your error handling code significantly.<br />
In particular, the <code>?</code> operator will automatically convert the error type of the fallible operation into the error type
of the function, if a conversion is possible (i.e. if there is a suitable <code>From</code> implementation)</p>
<h2 id="exercise-55"><a class="header" href="#exercise-55">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source"><code>05_ticket_v2/14_source</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-2"><a class="header" href="#wrapping-up-2">Wrapping up</a></h1>
<p>When it comes to domain modelling, the devil is in the details.<br />
Rust offers a wide range of tools to help you represent the constraints of your domain directly in the type system,
but it takes some practice to get it right and write code that looks idiomatic.</p>
<p>Let's close the chapter with one final refinement of our <code>Ticket</code> model.<br />
We'll introduce a new type for each of the fields in <code>Ticket</code> to encapsulate the respective constraints.<br />
Every time someone accesses a <code>Ticket</code> field, they'll get back a value that's guaranteed to be valid—i.e. a
<code>TicketTitle</code> instead of a <code>String</code>. They won't have to worry about the title being empty elsewhere in the code:
as long as they have a <code>TicketTitle</code>, they know it's valid <strong>by construction</strong>.</p>
<p>This is just an example of how you can use Rust's type system to make your code safer and more expressive.</p>
<h2 id="further-reading-9"><a class="header" href="#further-reading-9">Further reading</a></h2>
<ul>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a></li>
<li><a href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/">Using types to guarantee domain invariants</a></li>
</ul>
<h2 id="exercise-56"><a class="header" href="#exercise-56">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/15_outro"><code>05_ticket_v2/15_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>In the previous chapter we modelled <code>Ticket</code> in a vacuum: we defined its fields and their constraints, we learned
how to best represent them in Rust, but we didn't consider how <code>Ticket</code> fits into a larger system.
We'll use this chapter to build a simple workflow around <code>Ticket</code>, introducing a (rudimentary) management system to
store and retrieve tickets.</p>
<p>The task will give us an opportunity to explore new Rust concepts, such as:</p>
<ul>
<li>Stack-allocated arrays</li>
<li><code>Vec</code>, a growable array type, and slices</li>
<li><code>Iterator</code> and <code>IntoIterator</code>, for iterating over collections</li>
<li>Slices (<code>&amp;[T]</code>), to work with parts of a collection</li>
<li>Lifetimes, to describe how long references are valid</li>
<li><code>HashMap</code> and <code>BTreeMap</code>, two key-value data structures</li>
<li><code>Eq</code> and <code>Hash</code>, to compare keys in a <code>HashMap</code></li>
<li><code>Ord</code> and <code>PartialOrd</code>, to work with a <code>BTreeMap</code></li>
<li><code>Index</code> and <code>IndexMut</code>, to access elements in a collection</li>
</ul>
<h2 id="exercise-57"><a class="header" href="#exercise-57">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/00_intro"><code>06_ticket_management/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>As soon as we start talking about "ticket management" we need to think about a way to store <em>multiple</em> tickets.
In turn, this means we need to think about collections. In particular, homogeneous collections:
we want to store multiple instances of the same type.</p>
<p>What does Rust have to offer in this regard?</p>
<h2 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h2>
<p>A first attempt could be to use an <strong>array</strong>.<br />
Arrays in Rust are fixed-size collections of elements of the same type.</p>
<p>Here's how you can define an array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Array type syntax: [ &lt;type&gt; ; &lt;number of elements&gt; ]
let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>This creates an array of 3 integers, initialized with the values <code>1</code>, <code>2</code>, and <code>3</code>.<br />
The type of the array is <code>[u32; 3]</code>, which reads as "an array of <code>u32</code>s with a length of 3".</p>
<h3 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing elements</a></h3>
<p>You can access elements of an array using square brackets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
Arrays are <strong>zero-indexed</strong>, like everything in Rust. You've seen this before with string slices and field indexing in
tuples/tuple-like variants.</p>
<h3 id="out-of-bounds-access"><a class="header" href="#out-of-bounds-access">Out-of-bounds access</a></h3>
<p>If you try to access an element that's out of bounds, Rust will panic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // This will panic
<span class="boring">}</span></code></pre></pre>
<p>This is enforced at runtime using <strong>bounds checking</strong>. It comes with a small performance overhead, but it's how
Rust prevents buffer overflows.<br />
In some scenarios the Rust compiler can optimize away bounds checks, especially if iterators are involved—we'll speak
more about this later on.</p>
<p>If you don't want to panic, you can use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p>Since the size of an array is known at compile-time, the compiler can allocate the array on the stack.
If you run the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>You'll get the following memory layout:</p>
<pre><code class="language-text">        +---+---+---+
Stack:  | 1 | 2 | 3 |
        +---+---+---+
</code></pre>
<p>In other words, the size of an array is <code>std::mem::size_of::&lt;T&gt;() * N</code>, where <code>T</code> is the type of the elements and <code>N</code> is
the number of elements.<br />
You can access and replace each element in <code>O(1)</code> time.</p>
<h2 id="exercise-58"><a class="header" href="#exercise-58">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays"><code>06_ticket_management/01_arrays</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Arrays' strength is also their weakness: their size must be known upfront, at compile-time.
If you try to create an array with a size that's only known at runtime, you'll get a compilation error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 10;
let numbers: [u32; n];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0435]: attempt to use a non-constant value in a constant
 --&gt; src/main.rs:3:20
  |
2 | let n = 10;
3 | let numbers: [u32; n];
  |                    ^ non-constant value
</code></pre>
<p>Arrays wouldn't work for our ticket management system—we don't know how many tickets we'll need to store at compile-time.
This is where <code>Vec</code> comes in.</p>
<h2 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h2>
<p><code>Vec</code> is a growable array type, provided by the standard library.<br />
You can create an empty array using the <code>Vec::new</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers: Vec&lt;u32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>You would then push elements into the vector using the <code>push</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>numbers.push(1);
numbers.push(2);
numbers.push(3);
<span class="boring">}</span></code></pre></pre>
<p>New values are added to the end of the vector.<br />
You can also create an initialized vector using the <code>vec!</code> macro, if you know the values at creation time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-elements-1"><a class="header" href="#accessing-elements-1">Accessing elements</a></h2>
<p>The syntax for accessing elements is the same as with arrays:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>The index must be of type <code>usize</code>.<br />
You can also use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// You get a `None` if you try to access an out-of-bounds index
// rather than a panic.
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<p>Access is bounds-checked, just element access with arrays. It has O(1) complexity.</p>
<h2 id="memory-layout-2"><a class="header" href="#memory-layout-2">Memory layout</a></h2>
<p><code>Vec</code> is a heap-allocated data structure.<br />
When you create a <code>Vec</code>, it allocates memory on the heap to store the elements.</p>
<p>If you run the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<p>you'll get the following memory layout:</p>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p><code>Vec</code> keeps track of three things:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the vector, i.e. how many elements are in the vector.</li>
<li>The <strong>capacity</strong> of the vector, i.e. the number of elements that can fit in the space reserved on the heap.</li>
</ul>
<p>This layout should look familiar: it's exactly the same as <code>String</code>!<br />
That's not a coincidence: <code>String</code> is defined as a vector of bytes, <code>Vec&lt;u8&gt;</code>, under the hood:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-59"><a class="header" href="#exercise-59">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/02_vec"><code>06_ticket_management/02_vec</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resizing"><a class="header" href="#resizing">Resizing</a></h1>
<p>We said that <code>Vec</code> is a "growable" vector type, but what does that mean?
What happens if you try to insert an element into a <code>Vec</code> that's already at maximum capacity?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
numbers.push(3); // Max capacity reached
numbers.push(4); // What happens here?
<span class="boring">}</span></code></pre></pre>
<p>The <code>Vec</code> will <strong>resize</strong> itself.<br />
It will ask the allocator for a new (larger) chunk of heap memory, copy the elements over, and deallocate the old memory.</p>
<p>This operation can be expensive, as it involves a new memory allocation and copying all existing elements.</p>
<h2 id="vecwith_capacity"><a class="header" href="#vecwith_capacity"><code>Vec::with_capacity</code></a></h2>
<p>If you have a rough idea of how many elements you'll store in a <code>Vec</code>, you can use the <code>Vec::with_capacity</code>
method to pre-allocate enough memory upfront.<br />
This can avoid a new allocation when the <code>Vec</code> grows, but it may waste memory if you overestimate actual usage.</p>
<p>Evaluate on a case-by-case basis.</p>
<h2 id="exercise-60"><a class="header" href="#exercise-60">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing"><code>06_ticket_management/03_resizing</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration"><a class="header" href="#iteration">Iteration</a></h1>
<p>During the very first exercises, you learned that Rust lets you iterate over collections using <code>for</code> loops.
We were looking at ranges at that point (e.g. <code>0..5</code>), but the same holds true for collections like arrays and vectors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It works for `Vec`s
let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}

// It also works for arrays
let a: [u32; 3] = [1, 2, 3];
for n in a {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>It's time to understand how this works under the hood.</p>
<h2 id="for-desugaring"><a class="header" href="#for-desugaring"><code>for</code> desugaring</a></h2>
<p>Every time you write a <code>for</code> loop in Rust, the compiler <em>desugars</em> it into the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = IntoIterator::into_iter(v);
loop {
    match iter.next() {
        Some(n) =&gt; {
            println!("{}", n);
        }
        None =&gt; break,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>loop</code> is another looping construct, on top of <code>for</code> and <code>while</code>.<br />
A <code>loop</code> block will run forever, unless you explicitly <code>break</code> out of it.</p>
<h2 id="iterator-trait"><a class="header" href="#iterator-trait"><code>Iterator</code> trait</a></h2>
<p>The <code>next</code> method in the previous code snippet comes from the <code>Iterator</code> trait.
The <code>Iterator</code> trait is defined in Rust's standard library and provides a shared interface for
types that can produce a sequence of values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Item</code> associated type specifies the type of the values produced by the iterator.</p>
<p><code>next</code> returns the next value in the sequence.<br />
It returns <code>Some(value)</code> if there's a value to return, and <code>None</code> when there isn't.</p>
<p>Be careful: there is no guarantee that an iterator is exhausted when it returns <code>None</code>. That's only
guaranteed if the iterator implements the (more restrictive)
<a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> trait.</p>
<h2 id="intoiterator-trait"><a class="header" href="#intoiterator-trait"><code>IntoIterator</code> trait</a></h2>
<p>Not all types implement <code>Iterator</code>, but many can be converted into a type that does.<br />
That's where the <code>IntoIterator</code> trait comes in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>into_iter</code> method consumes the original value and returns an iterator over its elements.<br />
A type can only have one implementation of <code>IntoIterator</code>: there can be no ambiguity as to what <code>for</code> should desugar to.</p>
<p>One detail: every type that implements <code>Iterator</code> automatically implements <code>IntoIterator</code> as well.
They just return themselves from <code>into_iter</code>!</p>
<h2 id="bounds-checks"><a class="header" href="#bounds-checks">Bounds checks</a></h2>
<p>Iterating over iterators has a nice side effect: you can't go out of bounds, by design.<br />
This allows Rust to remove bounds checks from the generated machine code, making iteration faster.</p>
<p>In other words,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>is usually faster than</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for i in 0..v.len() {
    println!("{}", v[i]);
}
<span class="boring">}</span></code></pre></pre>
<p>There are exceptions to this rule: the compiler can sometimes prove that you're not going out of bounds even
with manual indexing, thus removing the bounds checks anyway. But in general, prefer iteration to indexing
where possible.</p>
<h2 id="exercise-61"><a class="header" href="#exercise-61">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators"><code>06_ticket_management/04_iterators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iter"><a class="header" href="#iter"><code>.iter()</code></a></h1>
<p><code>IntoIterator</code> <strong>consumes</strong> <code>self</code> to create an iterator.</p>
<p>This has its benefits: you get <strong>owned</strong> values from the iterator.
For example: if you call <code>.into_iter()</code> on a <code>Vec&lt;Ticket&gt;</code> you'll get an iterator that returns <code>Ticket</code> values.</p>
<p>That's also its downside: you can no longer use the original collection after calling <code>.into_iter()</code> on it.
Quite often you want to iterate over a collection without consuming it, looking at <strong>references</strong> to the values instead.
In the case of <code>Vec&lt;Ticket&gt;</code>, you'd want to iterate over <code>&amp;Ticket</code> values.</p>
<p>Most collections expose a method called <code>.iter()</code> that returns an iterator over references to the collection's elements.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
for n in numbers.iter() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>This pattern can be simplified by implementing <code>IntoIterator</code> for a <strong>reference to the collection</strong>.
In our example above, that would be <code>&amp;Vec&lt;Ticket&gt;</code>.<br />
The standard library does this, that's why the following code works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// `n` has type `&amp;u32` here
// We didn't have to call `.iter()` explicitly
// It was enough to use `&amp;numbers` in the `for` loop
for n in &amp;numbers {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>It's idiomatic to provide both options:</p>
<ul>
<li>An implementation of <code>IntoIterator</code> for a reference to the collection.</li>
<li>An <code>.iter()</code> method that returns an iterator over references to the collection's elements.</li>
</ul>
<p>The former is convenient in <code>for</code> loops, the latter is more explicit and can be used in other contexts.</p>
<h2 id="exercise-62"><a class="header" href="#exercise-62">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/05_iter"><code>06_ticket_management/05_iter</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Let's try to complete the previous exercise by adding an implementation of <code>IntoIterator</code> for <code>&amp;TicketStore</code>, for
maximum convenience in <code>for</code> loops.</p>
<p>Let's start by filling in the most "obvious" parts of the implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIterator for &amp;TicketStore {
    type Item = &amp;Ticket;
    type IntoIter = // What goes here?

    fn into_iter(self) -&gt; Self::IntoIter {
        self.tickets.iter()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>What should <code>type IntoIter</code> be set to?<br />
Intuitively, it should be the type returned by <code>self.tickets.iter()</code>, i.e. the type returned by <code>Vec::iter()</code>.<br />
If you check the standard library documentation, you'll find that <code>Vec::iter()</code> returns an <code>std::slice::Iter</code>.
The definition of <code>Iter</code> is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p><code>'a</code> is a <strong>lifetime parameter</strong>.</p>
<h2 id="lifetime-parameters"><a class="header" href="#lifetime-parameters">Lifetime parameters</a></h2>
<p>Lifetimes are <strong>labels</strong> used by the Rust compiler to keep track of how long a reference (either mutable or
immutable) is valid.<br />
The lifetime of a reference is constrained by the scope of the value it refers to. Rust always makes sure, at compile-time,
that references are not used after the value they refer to has been dropped, to avoid dangling pointers and use-after-free bugs.</p>
<p>This should sound familiar: we've already seen these concepts in action when we discussed ownership and borrowing.
Lifetimes are just a way to <strong>name</strong> how long a specific reference is valid.</p>
<p>Naming becomes important when you have multiple references and you need to clarify how they <strong>relate to each other</strong>.
Let's look at the signature of <code>Vec::iter()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    // Slightly simplified
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec::iter()</code> is generic over a lifetime parameter, named <code>'a</code>.<br />
<code>'a</code> is used to <strong>tie together</strong> the lifetime of the <code>Vec</code> and the lifetime of the <code>Iter</code> returned by <code>iter()</code>.
In plain English: the <code>Iter</code> returned by <code>iter()</code> cannot outlive the <code>Vec</code> reference (<code>&amp;self</code>) it was created from.</p>
<p>This is important because <code>Vec::iter</code>, as we discussed, returns an iterator over <strong>references</strong> to the <code>Vec</code>'s elements.
If the <code>Vec</code> is dropped, the references returned by the iterator would be invalid. Rust must make sure this doesn't happen,
and lifetimes are the tool it uses to enforce this rule.</p>
<h2 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h2>
<p>Rust has a set of rules, called <strong>lifetime elision rules</strong>, that allow you to omit explicit lifetime annotations in many cases.
For example, <code>Vec::iter</code>'s definition looks like this in <code>std</code>'s source code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No explicit lifetime parameter is present in the signature of <code>Vec::iter()</code>.
Elision rules imply that the lifetime of the <code>Iter</code> returned by <code>iter()</code> is tied to the lifetime of the <code>&amp;self</code> reference.
You can think of <code>'_</code> as a <strong>placeholder</strong> for the lifetime of the <code>&amp;self</code> reference.</p>
<p>See the <a href="06_ticket_management/06_lifetimes.html#references">References</a> section for a link to the official documentation on lifetime elision.<br />
In most cases, you can rely on the compiler telling you when you need to add explicit lifetime annotations.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">std::vec::Vec::iter</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/struct.Iter.html">std::slice::Iter</a></li>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision rules</a></li>
</ul>
<h2 id="exercise-63"><a class="header" href="#exercise-63">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes"><code>06_ticket_management/06_lifetimes</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinators"><a class="header" href="#combinators">Combinators</a></h1>
<p>Iterators can do so much more than <code>for</code> loops!<br />
If you look at the documentation for the <code>Iterator</code> trait, you'll find a <strong>vast</strong> collections of
methods that you can leverage to transform, filter, and combine iterators in various ways.</p>
<p>Let's mention the most common ones:</p>
<ul>
<li><code>map</code> applies a function to each element of the iterator.</li>
<li><code>filter</code> keeps only the elements that satisfy a predicate.</li>
<li><code>filter_map</code> combines <code>filter</code> and <code>map</code> in one step.</li>
<li><code>cloned</code> converts an iterator of references into an iterator of values, cloning each element.</li>
<li><code>enumerate</code> returns a new iterator that yields <code>(index, value)</code> pairs.</li>
<li><code>skip</code> skips the first <code>n</code> elements of the iterator.</li>
<li><code>take</code> stops the iterator after <code>n</code> elements.</li>
<li><code>chain</code> combines two iterators into one.</li>
</ul>
<p>These methods are called <strong>combinators</strong>.<br />
They are usually <strong>chained</strong> together to create complex transformations in a concise and readable way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
// The sum of the squares of the even numbers
let outcome: u32 = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>What's going on with the <code>filter</code> and <code>map</code> methods above?<br />
They take <strong>closures</strong> as arguments.</p>
<p>Closures are <strong>anonymous functions</strong>, i.e. functions that are not defined using the <code>fn</code> syntax we are used to.<br />
They are defined using the <code>|args| body</code> syntax, where <code>args</code> are the arguments and <code>body</code> is the function body.
<code>body</code> can be a block of code or a single expression.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An anonymous function that adds 1 to its argument
let add_one = |x| x + 1;
// Could be written with a block too:
let add_one = |x| { x + 1 };
<span class="boring">}</span></code></pre></pre>
<p>Closures can take more than one argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;
let sum = add(1, 2);
<span class="boring">}</span></code></pre></pre>
<p>They can also capture variables from their environment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let add_x = |y| x + y;
let sum = add_x(1);
<span class="boring">}</span></code></pre></pre>
<p>If necessary, you can specify the types of the arguments and/or the return type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Just the input type
let add_one = |x: i32| x + 1;
// Or both input and output types, using the `fn` syntax
let add_one: fn(i32) -&gt; i32 = |x| x + 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="collect"><a class="header" href="#collect"><code>collect</code></a></h2>
<p>What happens when you're done transforming an iterator using combinators?<br />
You either iterate over the transformed values using a <code>for</code> loop, or you collect them into a collection.</p>
<p>The latter is done using the <code>collect</code> method.<br />
<code>collect</code> consumes the iterator and collects its elements into a collection of your choice.</p>
<p>For example, you can collect the squares of the even numbers into a <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares_of_evens: Vec&lt;u32&gt; = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p><code>collect</code> is generic over its <strong>return type</strong>.<br />
Therefore you usually need to provide a type hint to help the compiler infer the correct type.
In the example above, we annotated the type of <code>squares_of_evens</code> to be <code>Vec&lt;u32&gt;</code>.
Alternatively, you can use the <strong>turbofish syntax</strong> to specify the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let squares_of_evens = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    // Turbofish syntax: `&lt;method_name&gt;::&lt;type&gt;()`
    // It's called turbofish because `::&lt;&gt;` looks like a fish
    .collect::&lt;Vec&lt;u32&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading-10"><a class="header" href="#further-reading-10">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>'s documentation</a> gives you an
overview of the methods available for iterators in <code>std</code>.</li>
<li><a href="https://docs.rs/itertools/">The <code>itertools</code> crate</a> defines even <strong>more</strong> combinators for iterators.</li>
</ul>
<h2 id="exercise-64"><a class="header" href="#exercise-64">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/07_combinators"><code>06_ticket_management/07_combinators</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p><code>TicketStore::to_dos</code> returns a <code>Vec&lt;&amp;Ticket&gt;</code>.<br />
That signature introduces a new heap allocation every time <code>to_dos</code> is called, which may be unnecessary depending
on what the caller needs to do with the result.
It'd be better if <code>to_dos</code> returned an iterator instead of a <code>Vec</code>, thus empowering the caller to decide whether to
collect the results into a <code>Vec</code> or just iterate over them.</p>
<p>That's tricky though!
What's the return type of <code>to_dos</code>, as implemented below?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; ??? {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unnameable-types"><a class="header" href="#unnameable-types">Unnameable types</a></h2>
<p>The <code>filter</code> method returns an instance of <code>std::iter::Filter</code>, which has the following definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; { /* fields omitted */ }
<span class="boring">}</span></code></pre></pre>
<p>where <code>I</code> is the type of the iterator being filtered on and <code>P</code> is the predicate used to filter the elements.<br />
We know that <code>I</code> is <code>std::slice::Iter&lt;'_, Ticket&gt;</code> in this case, but what about <code>P</code>?<br />
<code>P</code> is a closure, an <strong>anonymous function</strong>. As the name suggests, closures don't have a name,
so we can't write them down in our code.</p>
<p>Rust has a solution for this: <strong>impl Trait</strong>.</p>
<h2 id="impl-trait-1"><a class="header" href="#impl-trait-1"><code>impl Trait</code></a></h2>
<p><code>impl Trait</code> is a feature that allows you to return a type without specifying its name.
You just declare what trait(s) the type implements, and Rust figures out the rest.</p>
<p>In this case, we want to return an iterator of references to <code>Ticket</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Ticket&gt; {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it!</p>
<h2 id="generic"><a class="header" href="#generic">Generic?</a></h2>
<p><code>impl Trait</code> in return position is <strong>not</strong> a generic parameter.</p>
<p>Generics are placeholders for types that are filled in by the caller of the function.
A function with a generic parameter is <strong>polymorphic</strong>: it can be called with different types, and the compiler will generate
a different implementation for each type.</p>
<p>That's not the case with <code>impl Trait</code>.
The return type of a function with <code>impl Trait</code> is <strong>fixed</strong> at compile time, and the compiler will generate
a single implementation for it.
This is why <code>impl Trait</code> is also called <strong>opaque return type</strong>: the caller doesn't know the exact type of the return value,
only that it implements the specified trait(s). But the compiler knows the exact type, there is no polymorphism involved.</p>
<h2 id="rpit"><a class="header" href="#rpit">RPIT</a></h2>
<p>If you read RFCs or deep-dives about Rust, you might come across the acronym <strong>RPIT</strong>.<br />
It stands for <strong>"Return Position Impl Trait"</strong> and refers to the use of <code>impl Trait</code> in return position.</p>
<h2 id="exercise-65"><a class="header" href="#exercise-65">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait"><code>06_ticket_management/08_impl_trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-in-argument-position"><a class="header" href="#impl-trait-in-argument-position"><code>impl Trait</code> in argument position</a></h1>
<p>In the previous section, we saw how <code>impl Trait</code> can be used to return a type without specifying its name.<br />
The same syntax can also be used in <strong>argument position</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter(iter: impl Iterator&lt;Item = i32&gt;) {
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_iter</code> takes an iterator of <code>i32</code>s and prints each element.<br />
When used in <strong>argument position</strong>, <code>impl Trait</code> is equivalent to a generic parameter with a trait bound:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;T&gt;(iter: T) 
where
    T: Iterator&lt;Item = i32&gt;
{
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="downsides"><a class="header" href="#downsides">Downsides</a></h2>
<p>As a rule of thumb, prefer generics over <code>impl Trait</code> in argument position.<br />
Generics allow the caller to explicitly specify the type of the argument, using the turbofish syntax (<code>::&lt;&gt;</code>),
which can be useful for disambiguation. That's not the case with <code>impl Trait</code>.</p>
<h2 id="exercise-66"><a class="header" href="#exercise-66">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/09_impl_trait_2"><code>06_ticket_management/09_impl_trait_2</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>Let's go back to the memory layout of a <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p>We already remarked how <code>String</code> is just a <code>Vec&lt;u8&gt;</code> in disguise.<br />
The similarity should prompt you to ask: "What's the equivalent of <code>&amp;str</code> for <code>Vec</code>?"</p>
<h2 id="t"><a class="header" href="#t"><code>&amp;[T]</code></a></h2>
<p><code>[T]</code> is a <strong>slice</strong> of a contiguous sequence of elements of type <code>T</code>.<br />
It's most commonly used in its borrowed form, <code>&amp;[T]</code>.</p>
<p>There are various ways to create a slice reference from a <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Via index syntax
let slice: &amp;[i32] = &amp;numbers[..];
// Via a method
let slice: &amp;[i32] = numbers.as_slice();
// Or for a subset of the elements
let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p><code>Vec</code> implements the <code>Deref</code> trait using <code>[T]</code> as the target type, so you can use slice methods on a <code>Vec</code> directly
thanks to deref coercion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// Surprise, surprise: `iter` is not a method on `Vec`!
// It's a method on `&amp;[T]`, but you can call it on a `Vec` 
// thanks to deref coercion.
let sum: i32 = numbers.iter().sum();
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-layout-3"><a class="header" href="#memory-layout-3">Memory layout</a></h3>
<p>A <code>&amp;[T]</code> is a <strong>fat pointer</strong>, just like <code>&amp;str</code>.<br />
It consists of a pointer to the first element of the slice and the length of the slice.</p>
<p>If you have a <code>Vec</code> with three elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>and then create a slice reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p>you'll get this memory layout:</p>
<pre><code class="language-text">                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |  
           |                                    |
           v                                    | 
         +---+---+---+---+                      |
Heap:    | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<h3 id="vect-vs-t"><a class="header" href="#vect-vs-t"><code>&amp;Vec&lt;T&gt;</code> vs <code>&amp;[T]</code></a></h3>
<p>When you need to pass an immutable reference to a <code>Vec</code> to a function, prefer <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>.<br />
This allows the function to accept any kind of slice, not necessarily one backed by a <code>Vec</code>.</p>
<p>For example, you can then pass a subset of the elements in a <code>Vec</code>.
But it goes further than that—you could also pass a <strong>slice of an array</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let slice: &amp;[i32] = &amp;array;
<span class="boring">}</span></code></pre></pre>
<p>Array slices and <code>Vec</code> slices are the same type: they're fat pointers to a contiguous sequence of elements.
In the case of arrays, the pointer points to the stack rather than the heap, but that doesn't matter
when it comes to using the slice.</p>
<h2 id="exercise-67"><a class="header" href="#exercise-67">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/10_slices"><code>06_ticket_management/10_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-slices"><a class="header" href="#mutable-slices">Mutable slices</a></h1>
<p>Every time we've talked about slice types (like <code>str</code> and <code>[T]</code>), we've used their immutable borrow form (<code>&amp;str</code> and <code>&amp;[T]</code>).<br />
But slices can also be mutable!</p>
<p>Here's how you create a mutable slice:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];
let slice: &amp;mut [i32] = &amp;mut numbers;
<span class="boring">}</span></code></pre></pre>
<p>You can then modify the elements in the slice:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slice[0] = 42;
<span class="boring">}</span></code></pre></pre>
<p>This will change the first element of the <code>Vec</code> to <code>42</code>.</p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>When working with immutable borrows, the recommendation was clear: prefer slice references over references to
the owned type (e.g. <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>).<br />
That's <strong>not</strong> the case with mutable borrows.</p>
<p>Consider this scenario:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(2);
let mut slice: &amp;mut [i32] = &amp;mut numbers;
slice.push(1);
<span class="boring">}</span></code></pre></pre>
<p>It won't compile!<br />
<code>push</code> is a method on <code>Vec</code>, not on slices. This is the manifestation of a more general principle: Rust won't
allow you to add or remove elements from a slice. You will only be able to modify/replace the elements that are
already there.</p>
<p>In this regard, a <code>&amp;mut Vec</code> or a <code>&amp;mut String</code> are strictly more powerful than a <code>&amp;mut [T]</code> or a <code>&amp;mut str</code>.<br />
Choose the type that best fits based on the operations you need to perform.</p>
<h2 id="exercise-68"><a class="header" href="#exercise-68">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/11_mutable_slices"><code>06_ticket_management/11_mutable_slices</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ticket-ids"><a class="header" href="#ticket-ids">Ticket ids</a></h1>
<p>Let's think again about our ticket management system.<br />
Our ticket model right now looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>One thing is missing here: an <strong>identifier</strong> to uniquely identify a ticket.<br />
That identifier should be unique for each ticket. That can be guaranteed by generating it automatically when
a new ticket is created.</p>
<h2 id="refining-the-model"><a class="header" href="#refining-the-model">Refining the model</a></h2>
<p>Where should the id be stored?<br />
We could add a new field to the <code>Ticket</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>But we don't know the id before creating the ticket. So it can't be there from the get-go.<br />
It'd have to be optional:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: Option&lt;TicketId&gt;,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>That's also not ideal—we'd have to handle the <code>None</code> case every single time we retrieve a ticket from the store,
even though we know that the id should always be there once the ticket has been created.</p>
<p>The best solution is to have two different ticket <strong>states</strong>, represented by two separate types:
a <code>TicketDraft</code> and a <code>Ticket</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TicketDraft {
    pub title: TicketTitle,
    pub description: TicketDescription
}

pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>TicketDraft</code> is a ticket that hasn't been created yet. It doesn't have an id, and it doesn't have a status.<br />
A <code>Ticket</code> is a ticket that has been created. It has an id and a status.<br />
Since each field in <code>TicketDraft</code> and <code>Ticket</code> embeds its own constraints, we don't have to duplicate logic
across the two types.</p>
<h2 id="exercise-69"><a class="header" href="#exercise-69">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/12_two_states"><code>06_ticket_management/12_two_states</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexing"><a class="header" href="#indexing">Indexing</a></h1>
<p><code>TicketStore::get</code> returns an <code>Option&lt;&amp;Ticket&gt;</code> for a given <code>TicketId</code>.<br />
We've seen before how to access elements of arrays and vectors using Rust's
indexing syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![0, 1, 2];
assert_eq!(v[0], 0);
<span class="boring">}</span></code></pre></pre>
<p>How can we provide the same experience for <code>TicketStore</code>?<br />
You guessed right: we need to implement a trait, <code>Index</code>!</p>
<h2 id="index"><a class="header" href="#index"><code>Index</code></a></h2>
<p>The <code>Index</code> trait is defined in Rust's standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
pub trait Index&lt;Idx&gt;
{
    type Output;

    // Required method
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>It has:</p>
<ul>
<li>One generic parameter, <code>Idx</code>, to represent the index type</li>
<li>One associated type, <code>Output</code>, to represent the type we retrieved using the index</li>
</ul>
<p>Notice how the <code>index</code> method doesn't return an <code>Option</code>. The assumption is that
<code>index</code> will panic if you try to access an element that's not there, as it happens
for array and vec indexing.</p>
<h2 id="exercise-70"><a class="header" href="#exercise-70">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/13_index"><code>06_ticket_management/13_index</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-indexing"><a class="header" href="#mutable-indexing">Mutable indexing</a></h1>
<p><code>Index</code> allows read-only access. It doesn't let you mutate the value you
retrieved.</p>
<h2 id="indexmut"><a class="header" href="#indexmut"><code>IndexMut</code></a></h2>
<p>If you want to allow mutability, you need to implement the <code>IndexMut</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
pub trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt;
{
    // Required method
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p><code>IndexMut</code> can only be implemented if the type already implements <code>Index</code>,
since it unlocks an <em>additional</em> capability.</p>
<h2 id="exercise-71"><a class="header" href="#exercise-71">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/14_index_mut"><code>06_ticket_management/14_index_mut</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Our implementation of <code>Index</code>/<code>IndexMut</code> is not ideal: we need to iterate over the entire
<code>Vec</code> to retrieve a ticket by id; the algorithmic complexity is <code>O(n)</code>, where
<code>n</code> is the number of tickets in the store.</p>
<p>We can do better by using a different data structure for storing tickets: a <code>HashMap&lt;K, V&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;String, String&gt;` in this example).
let mut book_reviews = HashMap::new();

book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<p><code>HashMap</code> works with key-value pairs. It's generic over both: <code>K</code> is the generic
parameter for the key type, while <code>V</code> is the one for the value type.</p>
<p>The expected cost of insertions, retrievals and removals is <strong>constant</strong>, <code>O(1)</code>.
That sounds perfect for our usecase, doesn't it?</p>
<h2 id="key-requirements"><a class="header" href="#key-requirements">Key requirements</a></h2>
<p>There are no trait bounds on <code>HashMap</code>'s struct definition, but you'll find some
on its methods. Let's look at <code>insert</code>, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slightly simplified
impl&lt;K, V&gt; HashMap&lt;K, V&gt;
where
    K: Eq + Hash,
{
    pub fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The key type must implement the <code>Eq</code> and <code>Hash</code> traits.<br />
Let's dig into those two.</p>
<h2 id="hash"><a class="header" href="#hash"><code>Hash</code></a></h2>
<p>A hashing function (or hasher) maps a potentially infinite set of a values (e.g.
all possible strings) to a bounded range (e.g. a <code>u64</code> value).<br />
There are many different hashing functions around, each with different properties
(speed, collision risk, reversibility, etc.).</p>
<p>A <code>HashMap</code>, as the name suggests, uses a hashing function behind the scene.
It hashes your key and then uses that hash to store/retrieve the associated value.
This strategy requires the key type must be hashable, hence the <code>Hash</code> trait bound on <code>K</code>.</p>
<p>You can find the <code>Hash</code> trait in the <code>std::hash</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Hash {
    // Required method
    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
       where H: Hasher;
}
<span class="boring">}</span></code></pre></pre>
<p>You will rarely implement <code>Hash</code> manually. Most of the times you'll derive it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq"><a class="header" href="#eq"><code>Eq</code></a></h2>
<p><code>HashMap</code> must be able to compare keys for equality. This is particularly important
when dealing with hash collisions—i.e. when two different keys hash to the same value.</p>
<p>You may wonder: isn't that what the <code>PartialEq</code> trait is for? Almost!<br />
<code>PartialEq</code> is not enough for <code>HashMap</code> because it doesn't guarantee reflexivity, i.e. <code>a == a</code> is always <code>true</code>.<br />
For example, floating point numbers (<code>f32</code> and <code>f64</code>) implement <code>PartialEq</code>,
but they don't satisfy the reflexivity property: <code>f32::NAN == f32::NAN</code> is <code>false</code>.<br />
Reflexivity is crucial for <code>HashMap</code> to work correctly: without it, you wouldn't be able to retrieve a value
from the map using the same key you used to insert it.</p>
<p>The <code>Eq</code> trait extends <code>PartialEq</code> with the reflexivity property:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Eq: PartialEq {
    // No additional methods
}
<span class="boring">}</span></code></pre></pre>
<p>It's a marker trait: it doesn't add any new methods, it's just a way for you to say to the compiler
that the equality logic implemented in <code>PartialEq</code> is reflexive.</p>
<p>You can derive <code>Eq</code> automatically when you derive <code>PartialEq</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="eq-and-hash-are-linked"><a class="header" href="#eq-and-hash-are-linked"><code>Eq</code> and <code>Hash</code> are linked</a></h2>
<p>There is an implicit contract between <code>Eq</code> and <code>Hash</code>: if two keys are equal, their hashes must be equal too.
This is crucial for <code>HashMap</code> to work correctly. If you break this contract, you'll get nonsensical results
when using <code>HashMap</code>.</p>
<h2 id="exercise-72"><a class="header" href="#exercise-72">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap"><code>06_ticket_management/15_hashmap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordering"><a class="header" href="#ordering">Ordering</a></h1>
<p>By moving from a <code>Vec</code> to a <code>HashMap</code> we have improved the performance of our ticket management system,
and simplified our code in the process.<br />
It's not all roses, though. When iterating over a <code>Vec</code>-backed store, we could be sure that the tickets
would be returned in the order they were added.<br />
That's not the case with a <code>HashMap</code>: you can iterate over the tickets, but the order is random.</p>
<p>We can recover a consistent ordering by switching from a <code>HashMap</code> to a <code>BTreeMap</code>.</p>
<h2 id="btreemap"><a class="header" href="#btreemap"><code>BTreeMap</code></a></h2>
<p>A <code>BTreeMap</code> guarantees that entries are sorted by their keys.<br />
This is useful when you need to iterate over the entries in a specific order, or if you need to
perform range queries (e.g. "give me all tickets with an id between 10 and 20").</p>
<p>Just like <code>HashMap</code>, you won't find trait bounds on the definition of <code>BTreeMap</code>.
But you'll find trait bounds on its methods. Let's look at <code>insert</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `K` and `V` stand for the key and value types, respectively,
// just like in `HashMap`.
impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt;
    where
        K: Ord,
    {
        // implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Hash</code> is no longer required. Instead, the key type must implement the <code>Ord</code> trait.</p>
<h2 id="ord"><a class="header" href="#ord"><code>Ord</code></a></h2>
<p>The <code>Ord</code> trait is used to compare values.<br />
While <code>PartialEq</code> is used to compare for equality, <code>Ord</code> is used to compare for ordering.</p>
<p>It's defined in <code>std::cmp</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ord: Eq + PartialOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cmp</code> method returns an <code>Ordering</code> enum, which can be one
of <code>Less</code>, <code>Equal</code>, or <code>Greater</code>.<br />
<code>Ord</code> requires that two other traits are implemented: <code>Eq</code> and <code>PartialOrd</code>.</p>
<h2 id="partialord"><a class="header" href="#partialord"><code>PartialOrd</code></a></h2>
<p><code>PartialOrd</code> is a weaker version of <code>Ord</code>, just like <code>PartialEq</code> is a weaker version of <code>Eq</code>.
You can see why by looking at its definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialOrd: PartialEq {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>PartialOrd::partial_cmp</code> returns an <code>Option</code>—it is not guaranteed that two values can
be compared.<br />
For example, <code>f32</code> doesn't implement <code>Ord</code> because <code>NaN</code> values are not comparable,
the same reason why <code>f32</code> doesn't implement <code>Eq</code>.</p>
<h2 id="implementing-ord-and-partialord"><a class="header" href="#implementing-ord-and-partialord">Implementing <code>Ord</code> and <code>PartialOrd</code></a></h2>
<p>Both <code>Ord</code> and <code>PartialOrd</code> can be derived for your types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You need to add `Eq` and `PartialEq` too,
// since `Ord` requires them.
#[derive(Eq, PartialEq, Ord, PartialOrd)]
struct TicketId(u64);
<span class="boring">}</span></code></pre></pre>
<p>If you choose (or need) to implement them manually, be careful:</p>
<ul>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with <code>Eq</code> and <code>PartialEq</code>.</li>
<li><code>Ord</code> and <code>PartialOrd</code> must be consistent with each other.</li>
</ul>
<h2 id="exercise-73"><a class="header" href="#exercise-73">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/16_btreemap"><code>06_ticket_management/16_btreemap</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-1"><a class="header" href="#intro-1">Intro</a></h1>
<p>One of Rust's big promises is <em>fearless concurrency</em>: making it easier to write safe, concurrent programs.
We haven't seen much of that yet. All the work we've done so far has been single-threaded.
Time to change that!</p>
<p>In this chapter we'll make our ticket store multithreaded.<br />
We'll have the opportunity to touch most of Rust's core concurrency features, including:</p>
<ul>
<li>Threads, using the <code>std::thread</code> module</li>
<li>Message passing, using channels</li>
<li>Shared state, using <code>Arc</code>, <code>Mutex</code> and <code>RwLock</code></li>
<li><code>Send</code> and <code>Sync</code>, the traits that encode Rust's concurrency guarantees</li>
</ul>
<p>We'll also discuss various design patterns for multithreaded systems and some their trade-offs.</p>
<h2 id="exercise-74"><a class="header" href="#exercise-74">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/00_intro"><code>07_threads/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Before we start writing multithreaded code, let's take a step back and talk about what threads are
and why we might want to use them.</p>
<h2 id="what-is-a-thread"><a class="header" href="#what-is-a-thread">What is a thread?</a></h2>
<p>A <strong>thread</strong> is an execution context managed by the underlying operating system.<br />
Each thread has its own stack, instruction pointer, and program counter.</p>
<p>A single <strong>process</strong> can manage multiple threads.
These threads share the same memory space, which means they can access the same data.</p>
<p>Threads are a <strong>logical</strong> construct. In the end, you can only run one set of instructions
at a time on a CPU core, the <strong>physical</strong> execution unit.<br />
Since there can be many more threads than there are CPU cores, the operating system's
<strong>scheduler</strong> is in charge of deciding which thread to run at any given time,
partitioning CPU time among them to maximize throughput and responsiveness.</p>
<h2 id="main"><a class="header" href="#main"><code>main</code></a></h2>
<p>When a Rust program starts, it runs on a single thread, the <strong>main thread</strong>.<br />
This thread is created by the operating system and is responsible for running the <code>main</code>
function.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<p>Rust's standard library provides a module, <code>std::thread</code>, that allows you to create
and manage threads.</p>
<h3 id="spawn"><a class="header" href="#spawn"><code>spawn</code></a></h3>
<p>You can use <code>std::thread::spawn</code> to create new threads and execute code on them.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });
    
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre></pre>
<p>If you execute this program on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afedf7062298ca8f5a248bc551062eaa">Rust playground</a>
you'll see that the main thread and the spawned thread run concurrently.<br />
Each thread makes progress independently of the other.</p>
<h3 id="process-termination"><a class="header" href="#process-termination">Process termination</a></h3>
<p>When the main thread finishes, the overall process will exit.<br />
A spawned thread will continue running until it finishes or the main thread finishes.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    thread::sleep(Duration::from_secs(5));
}</code></pre></pre>
<p>In the example above, you can expect to see the message "Hello from a thread!" printed roughly five times.<br />
Then the main thread will finish (when the <code>sleep</code> call returns), and the spawned thread will be terminated
since the overall process exits.</p>
<h3 id="join"><a class="header" href="#join"><code>join</code></a></h3>
<p>You can also wait for a spawned thread to finish by calling the <code>join</code> method on the <code>JoinHandle</code> that <code>spawn</code> returns.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        println!("Hello from a thread!");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p>In this example, the main thread will wait for the spawned thread to finish before exiting.<br />
This introduces a form of <strong>synchronization</strong> between the two threads: you're guaranteed to see the message
"Hello from a thread!" printed before the program exits, because the main thread won't exit
until the spawned thread has finished.</p>
<h2 id="exercise-75"><a class="header" href="#exercise-75">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads"><code>07_threads/01_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static"><code>'static</code></a></h1>
<p>If you tried to borrow a slice from the vector in the previous exercise,
you probably got a compiler error that looks something like this:</p>
<pre><code class="language-text">error[E0597]: `v` does not live long enough
   |
11 | pub fn sum(v: Vec&lt;i32&gt;) -&gt; i32 {
   |            - binding `v` declared here
...
15 |     let right = &amp;v[split_point..];
   |                  ^ borrowed value does not live long enough
16 |     let left_handle = thread::spawn(move || left.iter().sum::&lt;i32&gt;());
   |                        ------------------------------------------------ 
                          argument requires that `v` is borrowed for `'static`
19 | }
   |  - `v` dropped here while still borrowed
</code></pre>
<p><code>argument requires that v is borrowed for 'static</code>, what does that mean?</p>
<p>The <code>'static</code> lifetime is a special lifetime in Rust.<br />
It means that the value will be valid for the entire duration of the program.</p>
<h2 id="detached-threads"><a class="header" href="#detached-threads">Detached threads</a></h2>
<p>A thread launched via <code>thread::spawn</code> can <strong>outlive</strong> the thread that spawned it.<br />
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

fn f() {
    thread::spawn(|| {
        thread::spawn(|| {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                println!("Hello from the detached thread!");
            }
        });
    });
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the first spawned thread will in turn spawn
a child thread that prints a message every second.<br />
The first thread will then finish and exit. When that happens,
its child thread will <strong>continue running</strong> for as long as the
overall process is running.<br />
In Rust's lingo, we say that the child thread has <strong>outlived</strong>
its parent.</p>
<h2 id="static-lifetime"><a class="header" href="#static-lifetime"><code>'static</code> lifetime</a></h2>
<p>Since a spawned thread can:</p>
<ul>
<li>outlive the thread that spawned it (its parent thread)</li>
<li>run until the program exits</li>
</ul>
<p>it must not borrow any values that might be dropped before the program exits;
violating this constraint would expose us to a use-after-free bug.<br />
That's why <code>std::thread::spawn</code>'s signature requires that the closure passed to it
has the <code>'static</code> lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static
{
    // [..]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-is-not-just-about-references"><a class="header" href="#static-is-not-just-about-references"><code>'static</code> is not (just) about references</a></h2>
<p>All values in Rust have a lifetime, not just references.</p>
<p>In particular, a type that owns its data (like a <code>Vec</code> or a <code>String</code>)
satisfies the <code>'static</code> constraint: if you own it, you can keep working with it
for as long as you want, even after the function that originally created it
has returned.</p>
<p>You can thus interpret <code>'static</code> as a way to say:</p>
<ul>
<li>Give me an owned value</li>
<li>Give me a reference that's valid for the entire duration of the program</li>
</ul>
<p>The first approach is how you solved the issue in the previous exercise:
by allocating new vectors to hold the left and right parts of the original vector,
which were then moved into the spawned threads.</p>
<h2 id="static-references"><a class="header" href="#static-references"><code>'static</code> references</a></h2>
<p>Let's talk about the second case, references that are valid for the entire
duration of the program.</p>
<h3 id="static-data"><a class="header" href="#static-data">Static data</a></h3>
<p>The most common case is a reference to <strong>static data</strong>, such as string literals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "Hello world!";
<span class="boring">}</span></code></pre></pre>
<p>Since string literals are known at compile-time, Rust stores them <em>inside</em> your executable,
in a region known as <strong>read-only data segment</strong>.
All references pointing to that region will therefore be valid for as long as
the program runs; they satisfy the <code>'static</code> contract.</p>
<h2 id="further-reading-11"><a class="header" href="#further-reading-11">Further reading</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_segment">The data segment</a></li>
</ul>
<h2 id="exercise-76"><a class="header" href="#exercise-76">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/02_static"><code>07_threads/02_static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leaking-data"><a class="header" href="#leaking-data">Leaking data</a></h1>
<p>The main concern around passing references to spawned threads is use-after-free bugs:
accessing data using a pointer to a memory region that's already been freed/de-allocated.<br />
If you're working with heap-allocated data, you can avoid the issue by
telling Rust that you'll never reclaim that memory: you choose to <strong>leak memory</strong>,
intentionally.</p>
<p>This can be done, for example, using the <code>Box::leak</code> method from Rust's standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocate a `u32` on the heap, by wrapping it in a `Box`.
let x = Box::new(41u32);
// Tell Rust that you'll never free that heap allocation
// using `Box::leak`. You can thus get back a 'static reference.
let static_ref: &amp;'static mut u32 = Box::leak(x);
<span class="boring">}</span></code></pre></pre>
<h2 id="data-leakage-is-process-scoped"><a class="header" href="#data-leakage-is-process-scoped">Data leakage is process-scoped</a></h2>
<p>Leaking data is dangerous: if you keep leaking memory, you'll eventually
run out and crash with an out-of-memory error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you leave this running for a while, 
// it'll eventually use all the available memory.
fn oom_trigger() {
    loop {
        let v: Vec&lt;usize&gt; = Vec::with_capacity(1024);
        Box::leak(v);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At the same time, memory leaked via <code>Box::leak</code> is not truly forgotten.<br />
The operating system can map each memory region to the process responsible for it.
When the process exits, the operating system will reclaim that memory.</p>
<p>Keeping this in mind, it can be OK to leak memory when:</p>
<ul>
<li>The amount of memory you need to leak is not unbounded/known upfront, or</li>
<li>Your process is short-lived and you're confident you won't exhaust
all the available memory before it exits</li>
</ul>
<p>"Let the OS deal with it" is a perfectly valid memory management strategy
if your usecase allows for it.</p>
<h2 id="exercise-77"><a class="header" href="#exercise-77">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak"><code>07_threads/03_leak</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threads"><a class="header" href="#scoped-threads">Scoped threads</a></h1>
<p>All the lifetime issues we discussed so far have a common source:
the spawned thread can outlive its parent.<br />
We can sidestep this issue by using <strong>scoped threads</strong>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

std::thread::scope(|scope| {
    scope.spawn(|| {
        let first = &amp;v[..midpoint];
        println!("Here's the first half of v: {first:?}");
    });
    scope.spawn(|| {
        let second = &amp;v[midpoint..];
        println!("Here's the second half of v: {second:?}");
    });
});

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<p>Let's unpack what's happening.</p>
<h2 id="scope"><a class="header" href="#scope"><code>scope</code></a></h2>
<p>The <code>std::thread::scope</code> function creates a new <strong>scope</strong>.<br />
<code>std::thread::scope</code> takes as input a closure, with a single argument: a <code>Scope</code> instance.</p>
<h2 id="scoped-spawns"><a class="header" href="#scoped-spawns">Scoped spawns</a></h2>
<p><code>Scope</code> exposes a <code>spawn</code> method.<br />
Unlike <code>std::thread::spawn</code>, all threads spawned using a <code>Scope</code> will be
<strong>automatically joined</strong> when the scope ends.</p>
<p>If we were to "translate" the previous example to <code>std::thread::spawn</code>,
it'd look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

let handle1 = std::thread::spawn(|| {
    let first = &amp;v[..midpoint];
    println!("Here's the first half of v: {first:?}");
});
let handle2 = std::thread::spawn(|| {
    let second = &amp;v[midpoint..];
    println!("Here's the second half of v: {second:?}");
});

handle1.join().unwrap();
handle2.join().unwrap();

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<h2 id="borrowing-from-the-environment"><a class="header" href="#borrowing-from-the-environment">Borrowing from the environment</a></h2>
<p>The translated example wouldn't compile, though: the compiler would complain
that <code>&amp;v</code> can't be used from our spawned threads since its lifetime isn't
<code>'static</code>.</p>
<p>That's not an issue with <code>std::thread::scope</code>—you can <strong>safely borrow from the environment</strong>.</p>
<p>In our example, <code>v</code> is created before the spawning points.
It will only be dropped <em>after</em> <code>scope</code> returns. At the same time,
all threads spawned inside <code>scope</code> are guaranteed to finish <em>before</em> <code>scope</code> returns,
therefore there is no risk of having dangling references.</p>
<p>The compiler won't complain!</p>
<h2 id="exercise-78"><a class="header" href="#exercise-78">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/04_scoped_threads"><code>07_threads/04_scoped_threads</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>All our spawned threads have been fairly short-lived so far.<br />
Get some input, run a computation, return the result, shut down.</p>
<p>For our ticket management system, we want to do something different:
a client-server architecture.</p>
<p>We will have <strong>one long-running server thread</strong>, responsible for managing
our state, the stored tickets.</p>
<p>We will then have <strong>multiple client threads</strong>.<br />
Each client will be able to send <strong>commands</strong> and <strong>queries</strong> to
the stateful thread, in order to change its state (e.g. add a new ticket)
or retrieve information (e.g. get the status of a ticket).<br />
Client threads will run concurrently.</p>
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<p>So far we've only had very limited parent-child communication:</p>
<ul>
<li>The spawned thread borrowed/consumed data from the parent context</li>
<li>The spawned thread returned data to the parent when joined</li>
</ul>
<p>This isn't enough for a client-server design.<br />
Clients need to be able to send and receive data from the server thread
<em>after</em> it has been launched.</p>
<p>We can solve the issue using <strong>channels</strong>.</p>
<h2 id="channels-1"><a class="header" href="#channels-1">Channels</a></h2>
<p>Rust's standard library provides <strong>multi-producer, single-consumer</strong> (mpsc) channels
in its <code>std::sync::mpsc</code> module.<br />
There are two channel flavours: bounded and unbounded. We'll stick to the unbounded
version for now, but we'll discuss the pros and cons later on.</p>
<p>Channel creation looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;

let (sender, receiver) = channel();
<span class="boring">}</span></code></pre></pre>
<p>You get a sender and a receiver.<br />
You call <code>send</code> on the sender to push data into the channel.<br />
You call <code>recv</code> on the receiver to pull data from the channel.</p>
<h3 id="multiple-senders"><a class="header" href="#multiple-senders">Multiple senders</a></h3>
<p><code>Sender</code> is clonable: we can create multiple senders (e.g. one for
each client thread) and they will all push data into the same channel.</p>
<p><code>Receiver</code>, instead, is not clonable: there can only be a single receiver
for a given channel.</p>
<p>That's what <strong>mpsc</strong> (multi-producer single-consumer) stands for!</p>
<h3 id="message-type"><a class="header" href="#message-type">Message type</a></h3>
<p>Both <code>Sender</code> and <code>Receiver</code> are generic over a type parameter <code>T</code>.<br />
That's the type of the <em>messages</em> that can travel on our channel.</p>
<p>It could be a <code>u64</code>, a struct, an enum, etc.</p>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<p>Both <code>send</code> and <code>recv</code> can fail.<br />
<code>send</code> returns an error if the receiver has been dropped.<br />
<code>recv</code> returns an error if all senders have been dropped and the channel is empty.</p>
<p>In other words, <code>send</code> and <code>recv</code> error when the channel is effectively closed.</p>
<h2 id="exercise-79"><a class="header" href="#exercise-79">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels"><code>07_threads/05_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interior-mutability"><a class="header" href="#interior-mutability">Interior mutability</a></h1>
<p>Let's take a moment to reason about the signature of <code>Sender</code>'s <code>send</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>send</code> takes <code>&amp;self</code> as its argument.<br />
But it's clearly causing a mutation: it's adding a new message to the channel.
What's even more interesting is that <code>Sender</code> is cloneable: we can have multiple instances of <code>Sender</code>
trying to modify the channel state <strong>at the same time</strong>, from different threads.</p>
<p>That's the key property we are using to build this client-server architecture. But why does it work?
Doesn't it violate Rust's rules about borrowing? How are we performing mutations via an <em>immutable</em> reference?</p>
<h2 id="shared-rather-than-immutable-references"><a class="header" href="#shared-rather-than-immutable-references">Shared rather than immutable references</a></h2>
<p>When we introduced the borrow-checker, we named the two types of references we can have in Rust:</p>
<ul>
<li>immutable references (<code>&amp;T</code>)</li>
<li>mutable references (<code>&amp;mut T</code>)</li>
</ul>
<p>It would have been more accurate to name them:</p>
<ul>
<li>shared references (<code>&amp;T</code>)</li>
<li>exclusive references (<code>&amp;mut T</code>)</li>
</ul>
<p>Immutable/mutable is a mental model that works for the vast majority of cases, and it's a great one to get started
with Rust. But it's not the whole story, as you've just seen: <code>&amp;T</code> doesn't actually guarantee that the data it
points to is immutable.<br />
Don't worry, though: Rust is still keeping its promises.
It's just that the terms are a bit more nuanced than they might seem at first.</p>
<h2 id="unsafecell"><a class="header" href="#unsafecell"><code>UnsafeCell</code></a></h2>
<p>Whenever a type allows you to mutate data through a shared reference, you're dealing with <strong>interior mutability</strong>.</p>
<p>By default, the Rust compiler assumes that shared references are immutable. It <strong>optimises your code</strong> based on that assumption.<br />
The compiler can reorder operations, cache values, and do all sorts of magic to make your code faster.</p>
<p>You can tell the compiler "No, this shared reference is actually mutable" by wrapping the data in an <code>UnsafeCell</code>.<br />
Every time you see a type that allows interior mutability, you can be certain that <code>UnsafeCell</code> is involved,
either directly or indirectly.<br />
Using <code>UnsafeCell</code>, raw pointers and <code>unsafe</code> code, you can mutate data through shared references.</p>
<p>Let's be clear, though: <code>UnsafeCell</code> isn't a magic wand that allows you to ignore the borrow-checker!<br />
<code>unsafe</code> code is still subject to Rust's rules about borrowing and aliasing.
It's an (advanced) tool that you can leverage to build <strong>safe abstractions</strong> whose safety can't be directly expressed
in Rust's type system. Whenever you use the <code>unsafe</code> keyword you're telling the compiler:
"I know what I'm doing, I won't violate your invariants, trust me."</p>
<p>Every time you call an <code>unsafe</code> function, there will be documentation explaining its <strong>safety preconditions</strong>:
under what circumstances it's safe to execute its <code>unsafe</code> block. You can find the ones for <code>UnsafeCell</code>
<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">in <code>std</code>'s documentation</a>.</p>
<p>We won't be using <code>UnsafeCell</code> directly in this course, nor will we be writing <code>unsafe</code> code.
But it's important to know that it's there, why it exists and how it relates to the types you use
every day in Rust.</p>
<h2 id="key-examples"><a class="header" href="#key-examples">Key examples</a></h2>
<p>Let's go through a couple of important <code>std</code> types that leverage interior mutability.<br />
These are types that you'll encounter somewhat often in Rust code, especially if you peek under the hood of
some the libraries you use.</p>
<h3 id="reference-counting"><a class="header" href="#reference-counting">Reference counting</a></h3>
<p><code>Rc</code> is a reference-counted pointer.<br />
It wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Rc</code> is immutable: you can only get shared references to it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let a: Rc&lt;String&gt; = Rc::new("My string".to_string());
// Only one reference to the string data exists.
assert_eq!(Rc::strong_count(&amp;a), 1);

// When we call `clone`, the string data is not copied!
// Instead, the reference count for `Rc` is incremented.
let b = Rc::clone(&amp;a);
assert_eq!(Rc::strong_count(&amp;a), 2);
assert_eq!(Rc::strong_count(&amp;b), 2);
// ^ Both `a` and `b` point to the same string data
//   and share the same reference counter.
<span class="boring">}</span></code></pre></pre>
<p><code>Rc</code> uses <code>UnsafeCell</code> internally to allow shared references to increment and decrement the reference count.</p>
<h3 id="refcell"><a class="header" href="#refcell"><code>RefCell</code></a></h3>
<p><code>RefCell</code> is one of the most common examples of interior mutability in Rust.
It allows you to mutate the value wrapped in a <code>RefCell</code> even if you only have an
immutable reference to the <code>RefCell</code> itself.</p>
<p>This is done via <strong>runtime borrow checking</strong>.
The <code>RefCell</code> keeps track of the number (and type) of references to the value it contains at runtime.
If you try to borrow the value mutably while it's already borrowed immutably,
the program will panic, ensuring that Rust's borrowing rules are always enforced.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // Immutable borrow
let z = x.borrow_mut(); // Panics! There is an active immutable borrow.
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-80"><a class="header" href="#exercise-80">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability"><code>07_threads/06_interior_mutability</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-way-communication"><a class="header" href="#two-way-communication">Two-way communication</a></h1>
<p>In our current client-server implementation, communication flows in one direction: from the client to the server.<br />
The client has no way of knowing if the server received the message, executed it successfully, or failed.
That's not ideal.</p>
<p>To solve this issue, we can introduce a two-way communication system.</p>
<h2 id="response-channel"><a class="header" href="#response-channel">Response channel</a></h2>
<p>We need a way for the server to send a response back to the client.<br />
There are various ways to do this, but the simplest option is to include a <code>Sender</code> channel in
the message that the client sends to the server. After processing the message, the server can use
this channel to send a response back to the client.</p>
<p>This is a fairly common pattern in Rust applications built on top of message-passing primitives.</p>
<h2 id="exercise-81"><a class="header" href="#exercise-81">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/07_ack"><code>07_threads/07_ack</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-dedicated-client-type"><a class="header" href="#a-dedicated-client-type">A dedicated <code>Client</code> type</a></h1>
<p>All the interactions from the client side have been fairly low-level: you have to
manually create a response channel, build the command, send it to the server, and
then call <code>recv</code> on the response channel to get the response.</p>
<p>This is a lot of boilerplate code that could be abstracted away, and that's
exactly what we're going to do in this exercise.</p>
<h2 id="exercise-82"><a class="header" href="#exercise-82">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/08_client"><code>07_threads/08_client</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-vs-unbounded-channels"><a class="header" href="#bounded-vs-unbounded-channels">Bounded vs unbounded channels</a></h1>
<p>So far we've been using unbounded channels.<br />
You can send as many messages as you want, and the channel will grow to accommodate them.<br />
In a multi-producer single-consumer scenario, this can be problematic: if the producers
enqueues messages at a faster rate than the consumer can process them, the channel will
keep growing, potentially consuming all available memory.</p>
<p>Our recommendation is to <strong>never</strong> use an unbounded channel in a production system.<br />
You should always enforce an upper limit on the number of messages that can be enqueued using a
<strong>bounded channel</strong>.</p>
<h2 id="bounded-channels"><a class="header" href="#bounded-channels">Bounded channels</a></h2>
<p>A bounded channel has a fixed capacity.<br />
You can create one by calling <code>sync_channel</code> with a capacity greater than zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
<span class="boring">}</span></code></pre></pre>
<p><code>receiver</code> has the same type as before, <code>Receiver&lt;T&gt;</code>.<br />
<code>sender</code>, instead, is an instance of <code>SyncSender&lt;T&gt;</code>.</p>
<h3 id="sending-messages"><a class="header" href="#sending-messages">Sending messages</a></h3>
<p>You have two different methods to send messages through a <code>SyncSender</code>:</p>
<ul>
<li><code>send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will block and wait until there is space available.</li>
<li><code>try_send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br />
If the channel is full, it will return <code>Err(TrySendError::Full(value))</code>, where <code>value</code> is the message that couldn't be sent.</li>
</ul>
<p>Depending on your use case, you might want to use one or the other.</p>
<h3 id="backpressure"><a class="header" href="#backpressure">Backpressure</a></h3>
<p>The main advantage of using bounded channels is that they provide a form of <strong>backpressure</strong>.<br />
They force the producers to slow down if the consumer can't keep up.
The backpressure can then propagate through the system, potentially affecting the whole architecture and
preventing end users from overwhelming the system with requests.</p>
<h2 id="exercise-83"><a class="header" href="#exercise-83">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded"><code>07_threads/09_bounded</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-operations"><a class="header" href="#update-operations">Update operations</a></h1>
<p>So far we've implemented only insertion and retrieval operations.<br />
Let's see how we can expand the system to provide an update operation.</p>
<h2 id="legacy-updates"><a class="header" href="#legacy-updates">Legacy updates</a></h2>
<p>In the non-threaded version of the system, updates were fairly straightforward: <code>TicketStore</code> exposed a
<code>get_mut</code> method that allowed the caller to obtain a mutable reference to a ticket, and then modify it.</p>
<h2 id="multithreaded-updates"><a class="header" href="#multithreaded-updates">Multithreaded updates</a></h2>
<p>The same strategy won't work in the current multi-threaded version,
because the mutable reference would have to be sent over a channel. The borrow checker would
stop us, because <code>&amp;mut Ticket</code> doesn't satisfy the <code>'static</code> lifetime requirement of <code>SyncSender::send</code>.</p>
<p>There are a few ways to work around this limitation. We'll explore a few of them in the following exercises.</p>
<h3 id="patching"><a class="header" href="#patching">Patching</a></h3>
<p>We can't send a <code>&amp;mut Ticket</code> over a channel, therefore we can't mutate on the client-side.<br />
Can we mutate on the server-side?</p>
<p>We can, if we tell the server what needs to be changed. In other words, if we send a <strong>patch</strong> to the server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TicketPatch {
    id: TicketId,
    title: Option&lt;TicketTitle&gt;,
    description: Option&lt;TicketDescription&gt;,
    status: Option&lt;TicketStatus&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>id</code> field is mandatory, since it's required to identify the ticket that needs to be updated.<br />
All other fields are optional:</p>
<ul>
<li>If a field is <code>None</code>, it means that the field should not be changed.</li>
<li>If a field is <code>Some(value)</code>, it means that the field should be changed to <code>value</code>.</li>
</ul>
<h2 id="exercise-84"><a class="header" href="#exercise-84">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/10_patch"><code>07_threads/10_patch</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locks-send-and-arc"><a class="header" href="#locks-send-and-arc">Locks, <code>Send</code> and <code>Arc</code></a></h1>
<p>The patching strategy you just implemented has a major drawback: it's racy.<br />
If two clients send patches for the same ticket roughly at same time, the server will apply them in an arbitrary order.
Whoever enqueues their patch last will overwrite the changes made by the other client.</p>
<h2 id="version-numbers"><a class="header" href="#version-numbers">Version numbers</a></h2>
<p>We could try to fix this by using a <strong>version number</strong>.<br />
Each ticket gets assigned a version number upon creation, set to <code>0</code>.<br />
Whenever a client sends a patch, they must include the current version number of the ticket alongside the
desired changes. The server will only apply the patch if the version number matches the one it has stored.</p>
<p>In the scenario described above, the server would reject the second patch, because the version number would
have been incremented by the first patch and thus wouldn't match the one sent by the second client.</p>
<p>This approach is fairly common in distributed systems (e.g. when client and servers don't share memory),
and it is known as <strong>optimistic concurrency control</strong>.<br />
The idea is that most of the time, conflicts won't happen, so we can optimize for the common case.
You know enough about Rust by now to implement this strategy on your own as a bonus exercise, if you want to.</p>
<h2 id="locking"><a class="header" href="#locking">Locking</a></h2>
<p>We can also fix the race condition by introducing a <strong>lock</strong>.<br />
Whenever a client wants to update a ticket, they must first acquire a lock on it. While the lock is active,
no other client can modify the ticket.</p>
<p>Rust's standard library provides two different locking primitives: <code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code>.<br />
Let's start with <code>Mutex&lt;T&gt;</code>. It stands for <strong>mut</strong>ual <strong>ex</strong>clusion, and it's the simplest kind of lock:
it allows only one thread to access the data, no matter if it's for reading or writing.</p>
<p><code>Mutex&lt;T&gt;</code> wraps the data it protects, and it's therefore generic over the type of the data.<br />
You can't access the data directly: the type system forces you to acquire a lock first using either <code>Mutex::lock</code> or
<code>Mutex::try_lock</code>. The former blocks until the lock is acquired, the latter returns immediately with an error if the lock
can't be acquired.<br />
Both methods return a guard object that dereferences to the data, allowing you to modify it. The lock is released when
the guard is dropped.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

// An integer protected by a mutex lock
let lock = Mutex::new(0);

// Acquire a lock on the mutex
let mut guard = lock.lock().unwrap();

// Modify the data through the guard,
// leveraging its `Deref` implementation
*guard += 1;

// The lock is released when `data` goes out of scope
// This can be done explicitly by dropping the guard
// or happen implicitly when the guard goes out of scope
drop(guard)
<span class="boring">}</span></code></pre></pre>
<h2 id="locking-granularity"><a class="header" href="#locking-granularity">Locking granularity</a></h2>
<p>What should our <code>Mutex</code> wrap?<br />
The simplest option would be the wrap the entire <code>TicketStore</code> in a single <code>Mutex</code>.<br />
This would work, but it would severely limit the system's performance: you wouldn't be able to read tickets in parallel,
because every read would have to wait for the lock to be released.<br />
This is known as <strong>coarse-grained locking</strong>.</p>
<p>It would be better to use <strong>fine-grained locking</strong>, where each ticket is protected by its own lock.
This way, clients can keep working with tickets in parallel, as long as they aren't trying to access the same ticket.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The new structure, with a lock for each ticket
struct TicketStore {
    tickets: BTreeMap&lt;TicketId, Mutex&lt;Ticket&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This approach is more efficient, but it has a downside: <code>TicketStore</code> has to become <strong>aware</strong> of the multithreaded
nature of the system; up until now, <code>TicketStore</code> has been blissfully ignored the existence of threads.<br />
Let's go for it anyway.</p>
<h2 id="who-holds-the-lock"><a class="header" href="#who-holds-the-lock">Who holds the lock?</a></h2>
<p>For the whole scheme to work, the lock must be passed to the client that wants to modify the ticket.<br />
The client can then directly modify the ticket (as if they had a <code>&amp;mut Ticket</code>) and release the lock when they're done.</p>
<p>This is a bit tricky.<br />
We can't send a <code>Mutex&lt;Ticket&gt;</code> over a channel, because <code>Mutex</code> is not <code>Clone</code> and
we can't move it out of the <code>TicketStore</code>. Could we send the <code>MutexGuard</code> instead?</p>
<p>Let's test the idea with a small example:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;
use std::sync::Mutex;
use std::sync::mpsc::sync_channel;

fn main() {
    let lock = Mutex::new(0);
    let (sender, receiver) = sync_channel(1);
    let guard = lock.lock().unwrap();

    spawn(move || {
        receiver.recv().unwrap();;
    });

    // Try to send the guard over the channel
    // to another thread
    sender.send(guard);
}</code></pre></pre>
<p>The compiler is not happy with this code:</p>
<pre><code class="language-text">error[E0277]: `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:10:7
    |
10  |   spawn(move || {
    |  _-----_^
    | | |
    | | required by a bound introduced by this call
11  | |     receiver.recv().unwrap();;
12  | | });
    | |_^ `MutexGuard&lt;'_, i32&gt;` cannot be sent between threads safely
    |
    = help: the trait `Send` is not implemented for `MutexGuard&lt;'_, i32&gt;`, which is required by `{closure@src/main.rs:10:7: 10:14}: Send`
    = note: required for `std::sync::mpsc::Receiver&lt;MutexGuard&lt;'_, i32&gt;&gt;` to implement `Send`
note: required because it's used within this closure
</code></pre>
<p><code>MutexGuard&lt;'_, i32&gt;</code> is not <code>Send</code>: what does it mean?</p>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><code>Send</code> is a marker trait that indicates that a type can be safely transferred from one thread to another.<br />
<code>Send</code> is also an auto-trait, just like <code>Sized</code>; it's automatically implemented (or not implemented) for your type
by the compiler, based on its definition.<br />
You can also implement <code>Send</code> manually for your types, but it requires <code>unsafe</code> since you have to guarantee that the
type is indeed safe to send between threads for reasons that the compiler can't automatically verify.</p>
<h3 id="channel-requirements"><a class="header" href="#channel-requirements">Channel requirements</a></h3>
<p><code>Sender&lt;T&gt;</code>, <code>SyncSender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code> are <code>Send</code> if and only if <code>T</code> is <code>Send</code>.<br />
That's because they are used to send values between threads, and if the value itself is not <code>Send</code>, it would be
unsafe to send it between threads.</p>
<h3 id="mutexguard"><a class="header" href="#mutexguard"><code>MutexGuard</code></a></h3>
<p><code>MutexGuard</code> is not <code>Send</code> because the underlying operating system primitives that <code>Mutex</code> uses to implement
the lock require (on some platforms) that the lock must be released by the same thread that acquired it.<br />
If we were to send a <code>MutexGuard</code> to another thread, the lock would be released by a different thread, which would
lead to undefined behavior.</p>
<h2 id="our-challenges"><a class="header" href="#our-challenges">Our challenges</a></h2>
<p>Summing it up:</p>
<ul>
<li>We can't send a <code>MutexGuard</code> over a channel. So we can't lock on the server-side and then modify the ticket on the
client-side.</li>
<li>We can send a <code>Mutex</code> over a channel because it's <code>Send</code> as long as the data it protects is <code>Send</code>, which is the
case for <code>Ticket</code>.
At the same time, we can't move the <code>Mutex</code> out of the <code>TicketStore</code> nor clone it.</li>
</ul>
<p>How can we solve this conundrum?<br />
We need to look at the problem from a different angle.
To lock a <code>Mutex</code>, we don't need an owned value. A shared reference is enough, since <code>Mutex</code> uses internal mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Mutex&lt;T&gt; {
    // `&amp;self`, not `self`!
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        // Implementation details
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It is therefore enough to send a shared reference to the client.<br />
We can't do that directly, though, because the reference would have to be <code>'static</code> and that's not the case.<br />
In a way, we need an "owned shared reference". It turns out that Rust has a type that fits the bill: <code>Arc</code>.</p>
<h2 id="arc-to-the-rescue"><a class="header" href="#arc-to-the-rescue"><code>Arc</code> to the rescue</a></h2>
<p><code>Arc</code> stands for <strong>atomic reference counting</strong>.<br />
<code>Arc</code> wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br />
The value wrapped in an <code>Arc</code> is immutable: you can only get shared references to it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let data: Arc&lt;u32&gt; = Arc::new(0);
let data_clone = Arc::clone(&amp;data);

// `Arc&lt;T&gt;` implements `Deref&lt;T&gt;`, so can convert 
// a `&amp;Arc&lt;T&gt;` to a `&amp;T` using deref coercion
let data_ref: &amp;u32 = &amp;data;
<span class="boring">}</span></code></pre></pre>
<p>If you're having a déjà vu moment, you're right: <code>Arc</code> sounds very similar to <code>Rc</code>, the reference-counted pointer we
introduced when talking about interior mutability. The difference is thread-safety: <code>Rc</code> is not <code>Send</code>, while <code>Arc</code> is.
It boils down to the way the reference count is implemented: <code>Rc</code> uses a "normal" integer, while <code>Arc</code> uses an
<strong>atomic</strong> integer, which can be safely shared and modified across threads.</p>
<h2 id="arcmutext"><a class="header" href="#arcmutext"><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></a></h2>
<p>If we pair <code>Arc</code> with <code>Mutex</code>, we finally get a type that:</p>
<ul>
<li>Can be sent between threads, because:
<ul>
<li><code>Arc</code> is <code>Send</code> if <code>T</code> is <code>Send</code>, and</li>
<li><code>Mutex</code> is <code>Send</code> if <code>T</code> is <code>Send</code>.</li>
<li><code>T</code> is <code>Ticket</code>, which is <code>Send</code>.</li>
</ul>
</li>
<li>Can be cloned, because <code>Arc</code> is <code>Clone</code> no matter what <code>T</code> is.
Cloning an <code>Arc</code> increments the reference count, the data is not copied.</li>
<li>Can be used to modify the data it wraps, because <code>Arc</code> lets you get a shared
reference to <code>Mutex&lt;T&gt;</code> which can in turn be used to acquire a lock.</li>
</ul>
<p>We have all the pieces we need to implement the locking strategy for our ticket store.</p>
<h2 id="further-reading-12"><a class="header" href="#further-reading-12">Further reading</a></h2>
<ul>
<li>We won't be covering the details of atomic operations in this course, but you can find more information
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">in the <code>std</code> documentation</a> as well as in the
<a href="https://marabos.nl/atomics/">"Rust atomics and locks" book</a>.</li>
</ul>
<h2 id="exercise-85"><a class="header" href="#exercise-85">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks"><code>07_threads/11_locks</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readers-and-writers"><a class="header" href="#readers-and-writers">Readers and writers</a></h1>
<p>Our new <code>TicketStore</code> works, but its read performance is not great: there can only be one client at a time
reading a specific ticket, because <code>Mutex&lt;T&gt;</code> doesn't distinguish between readers and writers.</p>
<p>We can solve the issue by using a different locking primitive: <code>RwLock&lt;T&gt;</code>.<br />
<code>RwLock&lt;T&gt;</code> stands for <strong>read-write lock</strong>. It allows <strong>multiple readers</strong> to access the data simultaneously,
but only one writer at a time.</p>
<p><code>RwLock&lt;T&gt;</code> has two methods to acquire a lock: <code>read</code> and <code>write</code>.<br />
<code>read</code> returns a guard that allows you to read the data, while <code>write</code> returns a guard that allows you to modify it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

// An integer protected by a read-write lock
let lock = RwLock::new(0);

// Acquire a read lock on the RwLock
let guard1 = lock.read().unwrap();

// Acquire a **second** read lock
// while the first one is still active
let guard2 = lock.read().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h2>
<p>On the surface, <code>RwLock&lt;T&gt;</code> seems like a no-brainer: it provides a superset of the functionality of <code>Mutex&lt;T&gt;</code>.
Why would you ever use <code>Mutex&lt;T&gt;</code> if you can use <code>RwLock&lt;T&gt;</code> instead?</p>
<p>There are two key reasons:</p>
<ul>
<li>Locking a <code>RwLock&lt;T&gt;</code> is more expensive than locking a <code>Mutex&lt;T&gt;</code>.<br />
This is because <code>RwLock&lt;T&gt;</code> has to keep track of the number of active readers and writers, while <code>Mutex&lt;T&gt;</code>
only has to keep track of whether the lock is held or not.
This performance overhead is not an issue if there are more readers than writers, but if the workload
is write-heavy <code>Mutex&lt;T&gt;</code> might be a better choice.</li>
<li><code>RwLock&lt;T&gt;</code> can cause <strong>writer starvation</strong>.<br />
If there are always readers waiting to acquire the lock, writers might never get a chance to run.<br />
<code>RwLock&lt;T&gt;</code> doesn't provide any guarantees about the order in which readers and writers are granted access to the lock.
It depends on the policy implemented by the underlying OS, which might not be fair to writers.</li>
</ul>
<p>In our case, we can expect the workload to be read-heavy (since most clients will be reading tickets, not modifying them),
so <code>RwLock&lt;T&gt;</code> is a good choice.</p>
<h2 id="exercise-86"><a class="header" href="#exercise-86">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock"><code>07_threads/12_rw_lock</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-review"><a class="header" href="#design-review">Design review</a></h1>
<p>Let's take a moment to review the journey we've been through.</p>
<h2 id="lockless-with-channel-serialization"><a class="header" href="#lockless-with-channel-serialization">Lockless with channel serialization</a></h2>
<p>Our first implementation of a multithreaded ticket store used:</p>
<ul>
<li>a single long-lived thread (server), to hold the shared state</li>
<li>multiple clients sending requests to it via channels from their own threads.</li>
</ul>
<p>No locking of the state was necessary, since the server was the only one modifying the state. That's because
the "inbox" channel naturally <strong>serialized</strong> incoming requests: the server would process them one by one.<br />
We've already discussed the limitations of this approach when it comes to patching behaviour, but we didn't
discuss the performance implications of the original design: the server could only process one request at a time,
including reads.</p>
<h2 id="fine-grained-locking"><a class="header" href="#fine-grained-locking">Fine-grained locking</a></h2>
<p>We then moved to a more sophisticated design, where each ticket was protected by its own lock and
clients could independently decide if they wanted to read or atomically modify a ticket, acquiring the appropriate lock.</p>
<p>This design allows for better parallelism (i.e. multiple clients can read tickets at the same time), but it is
still fundamentally <strong>serial</strong>: the server processes commands one by one. In particular, it hands out locks to clients
one by one.</p>
<p>Could we remove the channels entirely and allow clients to directly access the <code>TicketStore</code>, relying exclusively on
locks to synchronize access?</p>
<h2 id="removing-channels"><a class="header" href="#removing-channels">Removing channels</a></h2>
<p>We have two problems to solve:</p>
<ul>
<li>Sharing <code>TicketStore</code> across threads</li>
<li>Synchronizing access to the store</li>
</ul>
<h3 id="sharing-ticketstore-across-threads"><a class="header" href="#sharing-ticketstore-across-threads">Sharing <code>TicketStore</code> across threads</a></h3>
<p>We want all threads to refer to the same state, otherwise we don't really have a multithreaded system—we're just
running multiple single-threaded systems in parallel.<br />
We've already encountered this problem when we tried to share a lock across threads: we can use an <code>Arc</code>.</p>
<h3 id="synchronizing-access-to-the-store"><a class="header" href="#synchronizing-access-to-the-store">Synchronizing access to the store</a></h3>
<p>There is one interaction that's still lockless thanks to the serialization provided by the channels: inserting
(or removing) a ticket from the store.<br />
If we remove the channels, we need to introduce (another) lock to synchronize access to the <code>TicketStore</code> itself.</p>
<p>If we use a <code>Mutex</code>, then it makes no sense to use an additional <code>RwLock</code> for each ticket: the <code>Mutex</code> will
already serialize access to the entire store, so we wouldn't be able to read tickets in parallel anyway.<br />
If we use a <code>RwLock</code>, instead, we can read tickets in parallel. We just to pause all reads while inserting
or removing a ticket.</p>
<p>Let's go down this path and see where it leads us.</p>
<h2 id="exercise-87"><a class="header" href="#exercise-87">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/13_without_channels"><code>07_threads/13_without_channels</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<p>Before we wrap up this chapter, let's talk about another key trait in Rust's standard library: <code>Sync</code>.</p>
<p><code>Sync</code> is an auto trait, just like <code>Send</code>.<br />
It is automatically implemented by all types that can be safely <strong>shared</strong> between threads.</p>
<p>In order words: <code>T: Sync</code> means that <code>&amp;T</code> is <code>Send</code>.</p>
<h2 id="sync-doesnt-imply-send"><a class="header" href="#sync-doesnt-imply-send"><code>Sync</code> doesn't imply <code>Send</code></a></h2>
<p>It's important to note that <code>Sync</code> doesn't imply <code>Send</code>.<br />
For example: <code>MutexGuard</code> is not <code>Send</code>, but it is <code>Sync</code>.</p>
<p>It isn't <code>Send</code> because the lock must be released on the same thread that acquired it, therefore we don't
want <code>MutexGuard</code> to be dropped on a different thread.<br />
But it is <code>Sync</code>, because giving a <code>&amp;MutexGuard</code> to another thread has no impact on where the lock is released.</p>
<h2 id="send-doesnt-imply-sync"><a class="header" href="#send-doesnt-imply-sync"><code>Send</code> doesn't imply <code>Sync</code></a></h2>
<p>The opposite is also true: <code>Send</code> doesn't imply <code>Sync</code>.<br />
For example: <code>RefCell&lt;T&gt;</code> is <code>Send</code> (if <code>T</code> is <code>Send</code>), but it is not <code>Sync</code>.</p>
<p><code>RefCell&lt;T&gt;</code> performs runtime borrow checking, but the counters it uses to track borrows are not thread-safe.
Therefore, having multiple threads holding a <code>&amp;RefCell</code> would lead to a data race, with potentially
multiple threads obtaining mutable references to the same data. Hence <code>RefCell</code> is not <code>Sync</code>.<br />
<code>Send</code> is fine, instead, because when we send a <code>RefCell</code> to another thread we're not
leaving behind any references to the data it contains, hence no risk of concurrent mutable access.</p>
<h2 id="exercise-88"><a class="header" href="#exercise-88">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync"><code>07_threads/14_sync</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-rust"><a class="header" href="#async-rust">Async Rust</a></h1>
<p>Threads are not the only way to write concurrent programs in Rust.<br />
In this chapter we'll explore another approach: <strong>asynchronous programming</strong>.</p>
<p>In particular, you'll get an introduction to:</p>
<ul>
<li>The <code>async</code>/<code>.await</code> keywords, to write asynchronous code effortlessly</li>
<li>The <code>Future</code> trait, to represent computations that may not be complete yet</li>
<li><code>tokio</code>, the most popular runtime for running asynchronous code</li>
<li>The cooperative nature of Rust asynchronous model, and how this affects your code</li>
</ul>
<h2 id="exercise-89"><a class="header" href="#exercise-89">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/00_intro"><code>08_futures/00_intro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-functions"><a class="header" href="#asynchronous-functions">Asynchronous functions</a></h1>
<p>All the functions and methods you've written so far were eager.<br />
Nothing happened until you invoked them. But once you did, they ran to
completion: they did <strong>all</strong> their work, and then returned their output.</p>
<p>Sometimes that's undesirable.<br />
For example, if you're writing an HTTP server, there might be a lot of
<strong>waiting</strong>: waiting for the request body to arrive, waiting for the
database to respond, waiting for a downstream service to reply, etc.</p>
<p>What if you could do something else while you're waiting?<br />
What if you could choose to give up midway through a computation?<br />
What if you could choose to prioritise another task over the current one?</p>
<p>That's where <strong>asynchronous functions</strong> come in.</p>
<h2 id="async-fn"><a class="header" href="#async-fn"><code>async fn</code></a></h2>
<p>You use the <code>async</code> keyword to define an asynchronous function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

// This function is asynchronous
async fn bind_random() -&gt; TcpListener {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>What happens if you call <code>bind_random</code> as you would a regular function?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run() {
    // Invoke `bind_random`
    let listener = bind_random();
    // Now what?
}
<span class="boring">}</span></code></pre></pre>
<p>Nothing happens!<br />
Rust doesn't start executing <code>bind_random</code> when you call it,
not even as a background task (as you might expect based on your experience
with other languages).
Asynchronous functions in Rust are <strong>lazy</strong>: they don't do any work until you
explicitly ask them to.
Using Rust's terminology, we say that <code>bind_random</code> returns a <strong>future</strong>, a type
that represents a computation that may complete later. They're called futures
because they implement the <code>Future</code> trait, an interface that we'll examine in
detail later on in this chapter.</p>
<h2 id="await"><a class="header" href="#await"><code>.await</code></a></h2>
<p>The most common way to ask an asynchronous function to do some work is to use
the <code>.await</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

async fn bind_random() -&gt; TcpListener {
    // [...]
}

async fn run() {
    // Invoke `bind_random` and wait for it to complete
    let listener = bind_random().await;
    // Now `listener` is ready
}
<span class="boring">}</span></code></pre></pre>
<p><code>.await</code> doesn't return control to the caller until the asynchronous function
has run to completion—e.g. until the <code>TcpListener</code> has been created in the example above.</p>
<h2 id="runtimes"><a class="header" href="#runtimes">Runtimes</a></h2>
<p>If you're puzzled, you're right to be!<br />
We've just said that the perk of asynchronous functions
is that they don't do <strong>all</strong> their work at once. We then introduced <code>.await</code>, which
doesn't return until the asynchronous function has run to completion. Haven't we
just re-introduced the problem we were trying to solve? What's the point?</p>
<p>Not quite! A lot happens behind the scenes when you call <code>.await</code>!<br />
You're yielding control to an <strong>async runtime</strong>, also known as an <strong>async executor</strong>.
Executors are where the magic happens: they are in charge of managing all your
ongoing asynchronous <strong>tasks</strong>. In particular, they balance two different goals:</p>
<ul>
<li><strong>Progress</strong>: they make sure that tasks make progress whenever they can.</li>
<li><strong>Efficiency</strong>: if a task is waiting for something, they try to make sure that
another task can run in the meantime, fully utilising the available resources.</li>
</ul>
<h3 id="no-default-runtime"><a class="header" href="#no-default-runtime">No default runtime</a></h3>
<p>Rust is fairly unique in its approach to asynchronous programing: there is
no default runtime. The standard library doesn't ship with one. You need to
bring your own!</p>
<p>In most cases, you'll choose one of the options available in the ecosystem.
Some runtimes are designed to be broadly applicable, a solid option for most applications.
<code>tokio</code> and <code>async-std</code> belong to this category. Other runtimes are optimised for
specific use cases—e.g. <code>embassy</code> for embedded systems.</p>
<p>Throughout this course we'll rely on <code>tokio</code>, the most popular runtime for general-purpose
asynchronous programming in Rust.</p>
<h3 id="tokiomain"><a class="header" href="#tokiomain"><code>#[tokio::main]</code></a></h3>
<p>The entrypoint of your executable, the <code>main</code> function, must be a synchronous function.
That's where you're supposed to set up and launch your chosen async runtime.</p>
<p>Most runtimes provides a macro to make this easier. For <code>tokio</code>, it's <code>tokio::main</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    // Your async code goes here
}</code></pre></pre>
<p>which expands to:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // Your async function goes here
        // [...]
    );
}</code></pre></pre>
<h3 id="tokiotest"><a class="header" href="#tokiotest"><code>#[tokio::test]</code></a></h3>
<p>The same goes for tests: they must be synchronous functions.<br />
Each test function is run in its own thread, and you're responsible for
setting up and launching an async runtime if you need to run async code
in your tests.<br />
<code>tokio</code> provides a <code>#[tokio::test]</code> macro to make this easier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn my_test() {
    // Your async test code goes here
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-90"><a class="header" href="#exercise-90">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/01_async_fn"><code>08_futures/01_async_fn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-tasks"><a class="header" href="#spawning-tasks">Spawning tasks</a></h1>
<p>Your solution to the previous exercise should look something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        let (mut reader, mut writer) = socket.split();
        tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is not bad!<br />
If a long time passes between two incoming connections, the <code>echo</code> function will be idle
(since <code>TcpListener::accept</code> is an asynchronous function), thus allowing the executor
to run other tasks in the meantime.</p>
<p>But how can we actually have multiple tasks running concurrently?<br />
If we always run our asynchronous functions until completion (by using <code>.await</code>), we'll never
have more than one task running at a time.</p>
<p>This is where the <code>tokio::spawn</code> function comes in.</p>
<h2 id="tokiospawn"><a class="header" href="#tokiospawn"><code>tokio::spawn</code></a></h2>
<p><code>tokio::spawn</code> allows you to hand off a task to the executor, <strong>without waiting for it to complete</strong>.<br />
Whenever you invoke <code>tokio::spawn</code>, you're telling <code>tokio</code> to continue running
the spawned task, in the background, <strong>concurrently</strong> with the task that spawned it.</p>
<p>Here's how you can use it to process multiple connections concurrently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        // Spawn a background task to handle the connection
        // thus allowing the main task to immediately start 
        // accepting new connections
        tokio::spawn(async move {
            let (mut reader, mut writer) = socket.split();
            tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="asynchronous-blocks"><a class="header" href="#asynchronous-blocks">Asynchronous blocks</a></h3>
<p>In this example, we've passed an <strong>asynchronous block</strong> to <code>tokio::spawn</code>: <code>async move { /* */ }</code>
Asynchronous blocks are a quick way to mark a region of code as asynchronous without having
to define a separate async function.</p>
<h3 id="joinhandle"><a class="header" href="#joinhandle"><code>JoinHandle</code></a></h3>
<p><code>tokio::spawn</code> returns a <code>JoinHandle</code>.<br />
You can use <code>JoinHandle</code> to <code>.await</code> the background task, in the same way
we used <code>join</code> for spawned threads.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn run() {
    // Spawn a background task to ship telemetry data
    // to a remote server
    let handle = tokio::spawn(emit_telemetry());
    // In the meantime, do some other useful work
    do_work().await;
    // But don't return to the caller until 
    // the telemetry data has been successfully delivered
    handle.await;
}

pub async fn emit_telemetry() {
    // [...]
}

pub async fn do_work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="panic-boundary"><a class="header" href="#panic-boundary">Panic boundary</a></h3>
<p>If a task spawned with <code>tokio::spawn</code> panics, the panic will be caught by the executor.<br />
If you don't <code>.await</code> the corresponding <code>JoinHandle</code>, the panic won't be propagated to the spawner.
Even if you do <code>.await</code> the <code>JoinHandle</code>, the panic won't be propagated automatically.
Awaiting a <code>JoinHandle</code> returns a <code>Result</code>, with <a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinError.html"><code>JoinError</code></a>
as its error type. You can then check if the task panicked by calling <code>JoinError::is_panic</code> and
choose what to do with the panic—either log it, ignore it, or propagate it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::JoinError;

pub async fn run() {
    let handle = tokio::spawn(work());
    if let Err(e) = handle.await {
        if let Ok(reason) = e.try_into_panic() {
            // The task has panicked
            // We resume unwinding the panic,
            // thus propagating it to the current thread
            panic::resume_unwind(reason);
        }
    }
}

pub async fn work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stdthreadspawn-vs-tokiospawn"><a class="header" href="#stdthreadspawn-vs-tokiospawn"><code>std::thread::spawn</code> vs <code>tokio::spawn</code></a></h3>
<p>You can think of <code>tokio::spawn</code> as the asynchronous sibling of <code>std::spawn::thread</code>.</p>
<p>Notice a key difference: with <code>std::thread::spawn</code>, you're delegating control to the OS scheduler.
You're not in control of how threads are scheduled.</p>
<p>With <code>tokio::spawn</code>, you're delegating to an async executor that runs entirely in
user space. The underlying OS scheduler is not involved in the decision of which task
to run next. We're in charge of that decision now, via the executor we chose to use.</p>
<h2 id="exercise-91"><a class="header" href="#exercise-91">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/02_spawn"><code>08_futures/02_spawn</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-architecture"><a class="header" href="#runtime-architecture">Runtime architecture</a></h1>
<p>So far we've been talking about async runtimes as an abstract concept.
Let's dig a bit deeper into the way they are implemented—as you'll see soon enough,
it has an impact on our code.</p>
<h2 id="flavors"><a class="header" href="#flavors">Flavors</a></h2>
<p><code>tokio</code> ships two different runtime <em>flavors</em>.</p>
<p>You can configure your runtime via <code>tokio::runtime::Builder</code>:</p>
<ul>
<li><code>Builder::new_multi_thread</code> gives you a <strong>multithreaded <code>tokio</code> runtime</strong></li>
<li><code>Builder::new_current_thread</code> will instead rely on the <strong>current thread</strong> for execution.</li>
</ul>
<p><code>#[tokio::main]</code> returns a multithreaded runtime by default, while
<code>#[tokio::test]</code> uses a current thread runtime out of the box.</p>
<h3 id="current-thread-runtime"><a class="header" href="#current-thread-runtime">Current thread runtime</a></h3>
<p>The current-thread runtime, as the name implies, relies exclusively on the OS thread
it was launched on to schedule and execute tasks.<br />
When using the current-thread runtime, you have <strong>concurrency</strong> but no <strong>parallelism</strong>:
asynchronous tasks will be interleaved, but there will always be at most one task running
at any given time.</p>
<h3 id="multithreaded-runtime"><a class="header" href="#multithreaded-runtime">Multithreaded runtime</a></h3>
<p>When using the multithreaded runtime, instead, there can up to <code>N</code> tasks running
<em>in parallel</em> at any given time, where <code>N</code> is the number of threads used by the
runtime. By default, <code>N</code> matches the number of available CPU cores.</p>
<p>There's more: <code>tokio</code> performs <strong>work-stealing</strong>.<br />
If a thread is idle, it won't wait around: it'll try to find a new task that's ready for
execution, either from a global queue or by stealing it from the local queue of another
thread.<br />
Work-stealing can have significant performance benefits, especially on tail latencies,
whenever your application is dealing with workloads that are not perfectly balanced
across threads.</p>
<h2 id="implications"><a class="header" href="#implications">Implications</a></h2>
<p><code>tokio::spawn</code> is flavor-agnostic: it'll work no matter if you're running on the multithreaded
or current-thread runtime. The downside is that the signature assume the worst case
(i.e. multithreaded) and is constrained accordingly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>Let's ignore the <code>Future</code> trait for now to focus on the rest.<br />
<code>spawn</code> is asking all its inputs to be <code>Send</code> and have a <code>'static</code> lifetime.</p>
<p>The <code>'static</code> constraint follows the same rationale of the <code>'static</code> constraint
on <code>std::thread::spawn</code>: the spawned task may outlive the context it was spawned
from, therefore it shouldn't depend on any local data that may be de-allocated
after the spawning context is destroyed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner() {
    let v = vec![1, 2, 3];
    // This won't work, since `&amp;v` doesn't
    // live long enough.
    tokio::spawn(async { 
        for x in &amp;v {
            println!("{x}")
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p><code>Send</code>, on the other hand, is a direct consequence of <code>tokio</code>'s work-stealing strategy:
a task that was spawned on thread <code>A</code> may end up being moved to thread <code>B</code> if that's idle,
thus requiring a <code>Send</code> bound since we're crossing thread boundaries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner(input: Rc&lt;u64&gt;) {
    // This won't work either, because
    // `Rc` isn't `Send`.
    tokio::spawn(async move {
        println!("{}", input);
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-92"><a class="header" href="#exercise-92">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/03_runtime"><code>08_futures/03_runtime</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-future-trait"><a class="header" href="#the-future-trait">The <code>Future</code> trait</a></h1>
<h2 id="the-local-rc-problem"><a class="header" href="#the-local-rc-problem">The local <code>Rc</code> problem</a></h2>
<p>Let's go back to <code>tokio::spawn</code>'s signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>What does it <em>actually</em> mean for <code>F</code> to be <code>Send</code>?<br />
It implies, as we saw in the previous section, that whatever value it captures from the
spawning environment has to be <code>Send</code>. But it goes further than that.</p>
<p>Any value that's <em>held across a .await point</em> has to be <code>Send</code>.<br />
Let's look at an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

fn spawner() {
    tokio::spawn(example());
}

async fn example() {
    // A value that's not `Send`,
    // created _inside_ the async function
    let non_send = Rc::new(1);
    
    // A `.await` point that does nothing
    yield_now().await;

    // The local non-`Send` value is still needed
    // after the `.await`
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will reject this code:</p>
<pre><code class="language-text">error: future cannot be sent between threads safely
    |
5   |     tokio::spawn(example());
    |                  ^^^^^^^^^ future returned by `example` is not `Send`
    |
note: future is not `Send` as this value is used across an await
    |
11  |     let non_send = Rc::new(1);
    |         -------- has type `Rc&lt;i32&gt;` which is not `Send`
12  |     // A `.await` point
13  |     yield_now().await;
    |                 ^^^^^ await occurs here, with `non_send` maybe used later
note: required by a bound in `tokio::spawn`
    |
164 |     pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    |            ----- required by a bound in this function
165 |     where
166 |         F: Future + Send + 'static,
    |                     ^^^^ required by this bound in `spawn`
</code></pre>
<p>To understand why that's the case, we need to refine our understanding of
Rust's asynchronous model.</p>
<h2 id="the-future-trait-1"><a class="header" href="#the-future-trait-1">The <code>Future</code> trait</a></h2>
<p>We stated early on that <code>async</code> functions return <strong>futures</strong>, types that implement
the <code>Future</code> trait. You can think of a future as a <strong>state machine</strong>.
It's in one of two states:</p>
<ul>
<li><strong>pending</strong>: the computation has not finished yet.</li>
<li><strong>ready</strong>: the computation has finished, here's the output.</li>
</ul>
<p>This is encoded in the trait definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Future {
    type Output;
    
    // Ignore `Pin` and `Context` for now
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="poll"><a class="header" href="#poll"><code>poll</code></a></h3>
<p>The <code>poll</code> method is the heart of the <code>Future</code> trait.<br />
A future on its own doesn't do anything. It needs to be <strong>polled</strong> to make progress.<br />
When you call <code>poll</code>, you're asking the future to do some work.
<code>poll</code> tries to make progress, and then returns one of the following:</p>
<ul>
<li><code>Poll::Pending</code>: the future is not ready yet. You need to call <code>poll</code> again later.</li>
<li><code>Poll::Ready(value)</code>: the future has finished. <code>value</code> is the result of the computation,
of type <code>Self::Output</code>.</li>
</ul>
<p>Once <code>Future::poll</code> returns <code>Poll::Ready</code>, it should not be polled again: the future has
completed, there's nothing left to do.</p>
<h3 id="the-role-of-the-runtime"><a class="header" href="#the-role-of-the-runtime">The role of the runtime</a></h3>
<p>You'll rarely, if ever, be calling poll directly.<br />
That's the job of your async runtime: it has all the required information (the <code>Context</code>
in <code>poll</code>'s signature) to ensure that your futures are making progress whenever they can.</p>
<h2 id="async-fn-and-futures"><a class="header" href="#async-fn-and-futures"><code>async fn</code> and futures</a></h2>
<p>We've worked with the high-level interface, asynchronous functions.<br />
We've now looked at the low-level primitive, the <code>Future trait</code>.</p>
<p>How are they related?</p>
<p>Every time you mark a function as asynchronous, that function will return a future.
The compiler will transform the body of your asynchronous function into a <strong>state machine</strong>:
one state for each <code>.await</code> point.</p>
<p>Going back to our <code>Rc</code> example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

async fn example() {
    let non_send = Rc::new(1);
    yield_now().await;
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler would transform it into an enum that looks somewhat like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExampleFuture {
    NotStarted,
    YieldNow(Rc&lt;i32&gt;),
    Terminated,
}
<span class="boring">}</span></code></pre></pre>
<p>When <code>example</code> is called, it returns <code>ExampleFuture::NotStarted</code>. The future has never
been polled yet, so nothing has happened.<br />
When the runtime polls it the first time, <code>ExampleFuture</code> will advance until the next
<code>.await</code> point: it'll stop at the <code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code> stage of the state
machine, returning <code>Poll::Pending</code>.<br />
When it's polled again, it'll execute the remaining code (<code>println!</code>) and
return <code>Poll::Ready(())</code>.</p>
<p>When you look at its state machine representation, <code>ExampleFuture</code>,
it is now clear why <code>example</code> is not <code>Send</code>: it holds an <code>Rc</code>, therefore
it cannot be <code>Send</code>.</p>
<h2 id="yield-points"><a class="header" href="#yield-points">Yield points</a></h2>
<p>As you've just seen with <code>example</code>, every <code>.await</code> point creates a new intermediate
state in the lifecycle of a future.<br />
That's why <code>.await</code> points are also known as <strong>yield points</strong>: your future <em>yields control</em>
back to the runtime that was polling it, allowing the runtime to pause it and (if necessary)
schedule another task for execution, thus making progress on multiple fronts concurrently.</p>
<p>We'll come back to the importance of yielding in a later section.</p>
<h2 id="exercise-93"><a class="header" href="#exercise-93">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/04_future"><code>08_futures/04_future</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dont-block-the-runtime"><a class="header" href="#dont-block-the-runtime">Don't block the runtime</a></h1>
<p>Let's circle back to yield points.<br />
Unlike threads, <strong>Rust tasks cannot be preempted</strong>.</p>
<p><code>tokio</code> cannot, on its own, decide to pause a task and run another one in its place.
The control goes back to the executor <strong>exclusively</strong> when the task yields—i.e.
when <code>Future::poll</code> returns <code>Poll::Pending</code> or, in the case of <code>async fn</code>, when
you <code>.await</code> a future.</p>
<p>This exposes the runtime to a risk: if a task never yields, the runtime will never
be able to run another task. This is called <strong>blocking the runtime</strong>.</p>
<h2 id="what-is-blocking"><a class="header" href="#what-is-blocking">What is blocking?</a></h2>
<p>How long is too long? How much time can a task spend without yielding before it
becomes a problem?</p>
<p>It depends on the runtime, the application, the number of in-flight tasks, and
many other factors. But, as a general rule of thumb, try to spend less than 100
microseconds between yield points.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>Blocking the runtime can lead to:</p>
<ul>
<li><strong>Deadlocks</strong>: if the task that's not yielding is waiting for another task to
complete, and that task is waiting for the first one to yield, you have a deadlock.
No progress can be made, unless the runtime is able to schedule the other task on
a different thread.</li>
<li><strong>Starvation</strong>: other tasks might not be able to run, or might run after a long
delay, which can lead to poor performances (e.g. high tail latencies).</li>
</ul>
<h2 id="blocking-is-not-always-obvious"><a class="header" href="#blocking-is-not-always-obvious">Blocking is not always obvious</a></h2>
<p>Some types of operations should generally be avoided in async code, like:</p>
<ul>
<li>Synchronous I/O. You can't predict how long it will take, and it's likely to be
longer than 100 microseconds.</li>
<li>Expensive CPU-bound computations.</li>
</ul>
<p>The latter category is not always obvious though. For example, sorting a vector with
a few elements is not a problem; that evaluation changes if the vector has billions
of entries.</p>
<h2 id="how-to-avoid-blocking"><a class="header" href="#how-to-avoid-blocking">How to avoid blocking</a></h2>
<p>OK, so how do you avoid blocking the runtime assuming you <em>must</em> perform an operation
that qualifies or risks qualifying as blocking?<br />
You need to move the work to a different thread. You don't want to use the so-called
runtime threads, the ones used by <code>tokio</code> to run tasks.</p>
<p><code>tokio</code> provides a dedicated threadpool for this purpose, called the <strong>blocking pool</strong>.
You can spawn a synchronous operation on the blocking pool using the
<code>tokio::task::spawn_blocking</code> function. <code>spawn_blocking</code> returns a future that resolves
to the result of the operation when it completes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task;

fn expensive_computation() -&gt; u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);
    // Do other stuff in the meantime
    let result = handle.await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>The blocking pool is long-lived. <code>spawn_blocking</code> should be faster
than creating a new thread directly via <code>std::thread::spawn</code>
because the cost of thread initialization is amortized over multiple calls.</p>
<h2 id="further-reading-13"><a class="header" href="#further-reading-13">Further reading</a></h2>
<ul>
<li>Check out <a href="https://ryhl.io/blog/async-what-is-blocking/">Alice Ryhl's blog post</a>
on the topic.</li>
</ul>
<h2 id="exercise-94"><a class="header" href="#exercise-94">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking"><code>08_futures/05_blocking</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-aware-primitives"><a class="header" href="#async-aware-primitives">Async-aware primitives</a></h1>
<p>If you browse <code>tokio</code>'s documentation, you'll notice that it provides a lot of types
that "mirror" the ones in the standard library, but with an asynchronous twist:
locks, channels, timers, and more.</p>
<p>When working in an asynchronous context, you should prefer these asynchronous alternatives
to their synchronous counterparts.</p>
<p>To understand why, let's take a look at <code>Mutex</code>, the mutually exclusive lock we explored
in the previous chapter.</p>
<h2 id="case-study-mutex"><a class="header" href="#case-study-mutex">Case study: <code>Mutex</code></a></h2>
<p>Let's look at a simple example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().unwrap();
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
}

/// Use `v` as the body of an HTTP call.
async fn http_call(v: &amp;[u64]) {
  // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stdsyncmutexguard-and-yield-points"><a class="header" href="#stdsyncmutexguard-and-yield-points"><code>std::sync::MutexGuard</code> and yield points</a></h3>
<p>This code will compile, but it's dangerous.</p>
<p>We try to acquire a lock over a <code>Mutex</code> from <code>std</code> in an asynchronous context.
We then hold on to the resulting <code>MutexGuard</code> across a yield point (the <code>.await</code> on
<code>http_call</code>).</p>
<p>Let's imagine that there are two tasks executing <code>run</code>, concurrently, on a single-threaded
runtime. We observe the following sequence of scheduling events:</p>
<pre><code class="language-text">     Task A          Task B
        | 
  Acquire lock
Yields to runtime
        | 
        +--------------+
                       |
             Tries to acquire lock
</code></pre>
<p>We have a deadlock. Task B we'll never manage to acquire the lock, because the lock
is currently held by task A, which has yielded to the runtime before releasing the
lock and won't be scheduled again because the runtime cannot preempt task B.</p>
<h3 id="tokiosyncmutex"><a class="header" href="#tokiosyncmutex"><code>tokio::sync::Mutex</code></a></h3>
<p>You can solve the issue by switching to <code>tokio::sync::Mutex</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;&gt;) {
    let guard = m.lock().await;
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard` is dropped here
}
<span class="boring">}</span></code></pre></pre>
<p>Acquiring the lock is now an asynchronous operation, which yields back to the runtime
if it can't make progress.<br />
Going back to the previous scenario, the following would happen:</p>
<pre><code class="language-text">       Task A          Task B
          | 
  Acquires the lock
  Starts `http_call`
  Yields to runtime
          | 
          +--------------+
                         |
             Tries to acquire the lock
              Cannot acquire the lock
                 Yields to runtime
                         |
          +--------------+
          |
`http_call` completes      
  Releases the lock
   Yield to runtime
          |
          +--------------+
                         |
                 Acquires the lock
                       [...]
</code></pre>
<p>All good!</p>
<h3 id="multithreaded-wont-save-you"><a class="header" href="#multithreaded-wont-save-you">Multithreaded won't save you</a></h3>
<p>We've used a single-threaded runtime as the execution context in our
previous example, but the same risk persists even when using a multithreaded
runtime.<br />
The only difference is in the number of concurrent tasks required to create the deadlock:
in a single-threaded runtime, 2 are enough; in a multithreaded runtime, we
would need <code>N+1</code> tasks, where <code>N</code> is the number of runtime threads.</p>
<h3 id="downsides-1"><a class="header" href="#downsides-1">Downsides</a></h3>
<p>Having an async-aware <code>Mutex</code> comes with a performance penalty.<br />
If you're confident that the lock isn't under significant contention
<em>and</em> you're careful to never hold it across a yield point, you can
still use <code>std::sync::Mutex</code> in an asynchronous context.</p>
<p>But weigh the performance benefit against the liveness risk you
will incur.</p>
<h2 id="other-primitives"><a class="header" href="#other-primitives">Other primitives</a></h2>
<p>We used <code>Mutex</code> as an example, but the same applies to <code>RwLock</code>, semaphores, etc.<br />
Prefer async-aware versions when working in an asynchronous context to minimise
the risk of issues.</p>
<h2 id="exercise-95"><a class="header" href="#exercise-95">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/06_async_aware_primitives"><code>08_futures/06_async_aware_primitives</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h1>
<p>What happens when a pending future is dropped?<br />
The runtime will no longer poll it, therefore it won't make any further progress.
In other words, its execution has been <strong>cancelled</strong>.</p>
<p>In the wild, this often happens when working with timeouts.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::timeout;
use tokio::sync::oneshot;
use std::time::Duration;

async fn http_call() {
    // [...]
}

async fn run() {
    // Wrap the future with a `Timeout` set to expire in 10 milliseconds.
    let duration = Duration::from_millis(10);
    if let Err(_) = timeout(duration, http_call()).await {
        println!("Didn't receive a value within 10 ms");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When the timeout expires, the future returned by <code>http_call</code> will be cancelled.
Let's imagine that this is <code>http_call</code>'s body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::TcpStream;

async fn http_call() {
    let (stream, _) = TcpStream::connect(/* */).await.unwrap();
    let request: Vec&lt;u8&gt; = /* */;
    stream.write_all(&amp;request).await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>Each yield point becomes a <strong>cancellation point</strong>.<br />
<code>http_call</code> can't be preempted by the runtime, so it can only be discarded after
it has yielded control back to the executor via <code>.await</code>.
This applies recursively—e.g. <code>stream.write_all(&amp;request)</code> is likely to have multiple
yield points in its implementation. It is perfectly possible to see <code>http_call</code> pushing
a <em>partial</em> request before being cancelled, thus dropping the connection and never
finishing transmitting the body.</p>
<h2 id="clean-up"><a class="header" href="#clean-up">Clean up</a></h2>
<p>Rust's cancellation mechanism is quite powerful—it allows the caller to cancel an ongoing task
without needing any form of cooperation from the task itself.<br />
At the same time, this can be quite dangerous. It may be desirable to perform a
<strong>graceful cancellation</strong>, to ensure that some clean-up tasks are performed
before aborting the operation.</p>
<p>For example, consider this fictional API for a SQL transaction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_money(
    connection: SqlConnection,
    payer_id: u64,
    payee_id: u64,
    amount: u64
) -&gt; Result&lt;(), anyhow::Error&gt; {
    let transaction = connection.begin_transaction().await?;
    update_balance(payer_id, amount, &amp;transaction).await?;
    decrease_balance(payee_id, amount, &amp;transaction).await?;
    transaction.commit().await?;
}
<span class="boring">}</span></code></pre></pre>
<p>On cancellation, it'd be ideal to explicitly abort the pending transaction rather
than leaving it hanging.
Rust, unfortunately, doesn't provide a bullet-proof mechanism for this kind of
<strong>asynchronous</strong> clean up operations.</p>
<p>The most common strategy is to rely on the <code>Drop</code> trait to schedule the required
clean-up work. This can be by:</p>
<ul>
<li>Spawning a new task on the runtime</li>
<li>Enqueueing a message on a channel</li>
<li>Spawning a background thread</li>
</ul>
<p>The optimal choice is contextual.</p>
<h2 id="cancelling-spawned-tasks"><a class="header" href="#cancelling-spawned-tasks">Cancelling spawned tasks</a></h2>
<p>When you spawn a task using <code>tokio::spawn</code>, you can no longer drop it;
it belongs to the runtime.<br />
Nonetheless, you can use its <code>JoinHandle</code> to cancel it if needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run() {
    let handle = tokio::spawn(/* some async task */);
    // Cancel the spawned task
    handle.abort();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="further-reading-14"><a class="header" href="#further-reading-14">Further reading</a></h2>
<ul>
<li>Be extremely careful when using <code>tokio</code>'s <code>select!</code> macro to "race" two different futures.
Retrying the same task in a loop is dangerous unless you can ensure <strong>cancellation safety</strong>.
Check out <a href="https://tokio.rs/tokio/tutorial/select"><code>select!</code>'s documentation</a> for more details.<br />
If you need to interleave two asynchronous streams of data (e.g. a socket and a channel), prefer using
<a href="https://docs.rs/tokio-stream/latest/tokio_stream/trait.StreamExt.html#method.merge"><code>StreamExt::merge</code></a> instead.</li>
<li>Rather than "abrupt" cancellation, it can be preferable to rely
on <a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>CancellationToken</code></a>.</li>
</ul>
<h2 id="exercise-96"><a class="header" href="#exercise-96">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/07_cancellation"><code>08_futures/07_cancellation</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outro"><a class="header" href="#outro">Outro</a></h1>
<p>Rust's asynchronous model is quite powerful, but it does introduce additional
complexity. Take time to know your tools: dive deep into <code>tokio</code>'s documentation
and get familiar with its primitives to make the most out of it.</p>
<p>Keep in mind, as well, that there is ongoing work at the language and <code>std</code> level
to streamline and "complete" Rust's asynchronous story. You may experience some
rough edges in your day-to-day work due to some of these missing pieces.</p>
<p>A few recommendations for a mostly-pain-free async experience:</p>
<ul>
<li><strong>Pick a runtime and stick to it.</strong><br />
Some primitives (e.g. timers, I/O) are not portable across runtimes. Trying to
mix runtimes is likely to cause you pain. Trying to write code that's runtime
agnostic can significantly increase the complexity of your codebase. Avoid it
if you can.</li>
<li><strong>There is no stable <code>Stream</code>/<code>AsyncIterator</code> interface yet.</strong><br />
An <code>AsyncIterator</code> is, conceptually, an iterator that yields new items
asynchronously. There is ongoing design work, but no consensus (yet).
If you're using <code>tokio</code>, refer to <a href="https://docs.rs/tokio-stream/latest/tokio_stream/"><code>tokio_stream</code></a>
as your go-to interface.</li>
<li><strong>Be careful with buffering.</strong><br />
It is often the cause of subtle bugs. Check out
<a href="https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_battles_buffered_streams.html">"Barbara battles buffered streams"</a>
for more details.</li>
<li><strong>There is no equivalent of scoped threads for asynchronous tasks</strong>.<br />
Check out <a href="https://without.boats/blog/the-scoped-task-trilemma/">"The scoped task trilemma"</a>
for more details.</li>
</ul>
<p>Don't let these caveats scare you: asynchronous Rust is being used effectively
at <em>massive</em> scale (e.g. AWS, Meta) to power foundational services.<br />
You will have to master it if you're planning building networked applications
in Rust.</p>
<h2 id="exercise-97"><a class="header" href="#exercise-97">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/08_outro"><code>08_futures/08_outro</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<p>Our tour of Rust ends here.<br />
It has been quite extensive, but by no means exhaustive: Rust is a language with
a large surface area, and an even larger ecosystem!<br />
Don't let this scare you, though: there's <strong>no need to learn everything</strong>.
You'll pick up whatever is necessary to be effective in the domain
(backend, embedded, CLIs, GUIs, etc.) <strong>while working on your projects</strong>.</p>
<p>In the end, there are no shortcuts: if you want to get good at something,
you need to do it, over and over again. Throughout this course you wrote a fair
amount of Rust, enough to get the language and its syntax flowing under your
fingers. It'll take many more lines of code to feel it "yours", but that moment
will come without a doubt if you keep practicing.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>Let's close with some pointers to additional resources that you might find
useful as you move forward in your journey with Rust.</p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<p>You can find more exercises to practice Rust in the <a href="https://github.com/rust-lang/rustlings"><code>rustlings</code></a>
project and on <a href="https://exercism.io">exercism.io</a>'s Rust track.</p>
<h3 id="introductory-material"><a class="header" href="#introductory-material">Introductory material</a></h3>
<p>Check out <a href="https://doc.rust-lang.org/book/title-page.html">the Rust book</a> and
<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">"Programming Rust"</a>
if you're looking for a different perspective on the same concepts we covered throughout this course.
The material doesn't overlap perfectly, therefore you'll certainly learn something new along the
way.</p>
<h3 id="advanced-material"><a class="header" href="#advanced-material">Advanced material</a></h3>
<p>If you want to dive deeper into the language, refer to the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>
and <a href="https://nostarch.com/rust-rustaceans">"Rust for Rustaceans"</a>.<br />
The <a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z">"Decrusted" series</a> is another excellent
resource to learn more about the internals of many of the most popular Rust libraries.</p>
<h3 id="domain-specific-material"><a class="header" href="#domain-specific-material">Domain-specific material</a></h3>
<p>If you want to use Rust for backend development,
check out <a href="https://zero2prod.com">"Zero to Production in Rust"</a>.<br />
If you want to use Rust for embedded development,
check out the <a href="https://docs.rust-embedded.org/book/">Embedded Rust book</a>.</p>
<h3 id="masterclasses"><a class="header" href="#masterclasses">Masterclasses</a></h3>
<p>You can then find resources on key topics that cut across domains.<br />
For testing, check out
<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">"Advanced testing, going beyond the basics"</a>.<br />
For telemetry, check out <a href="https://github.com/mainmatter/rust-telemetry-workshop">"You can't fix what you can't see"</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
